import { pgTable, foreignKey, unique, text, timestamp, varchar, boolean, integer } from "drizzle-orm/pg-core"
import { sql } from "drizzle-orm"



export const session = pgTable("session", {
	id: text().primaryKey().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	token: text().notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	ipAddress: text("ip_address"),
	userAgent: text("user_agent"),
	userId: text("user_id").notNull(),
	impersonatedBy: text("impersonated_by"),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "session_user_id_user_id_fk"
	}).onDelete("cascade"),
	unique("session_token_unique").on(table.token),
]);

export const emailDomains = pgTable("email_domains", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	domain: varchar({ length: 255 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	verificationToken: varchar("verification_token", { length: 255 }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	canReceiveEmails: boolean("can_receive_emails").default(false),
	hasMxRecords: boolean("has_mx_records").default(false),
	domainProvider: varchar("domain_provider", { length: 100 }),
	providerConfidence: varchar("provider_confidence", { length: 20 }),
	lastDnsCheck: timestamp("last_dns_check", { mode: 'string' }),
	lastSesCheck: timestamp("last_ses_check", { mode: 'string' }),
	isCatchAllEnabled: boolean("is_catch_all_enabled").default(false),
	catchAllWebhookId: varchar("catch_all_webhook_id", { length: 255 }),
	catchAllReceiptRuleName: varchar("catch_all_receipt_rule_name", { length: 255 }),
}, (table) => [
	unique("email_domains_domain_unique").on(table.domain),
]);

export const subscriptions = pgTable("subscriptions", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	plan: varchar({ length: 255 }).notNull(),
	referenceId: varchar("reference_id", { length: 255 }).notNull(),
	stripeCustomerId: varchar("stripe_customer_id", { length: 255 }),
	stripeSubscriptionId: varchar("stripe_subscription_id", { length: 255 }),
	status: varchar({ length: 255 }).notNull(),
	periodStart: timestamp("period_start", { mode: 'string' }),
	periodEnd: timestamp("period_end", { mode: 'string' }),
	cancelAtPeriodEnd: boolean("cancel_at_period_end").default(false),
	seats: integer(),
	trialStart: timestamp("trial_start", { mode: 'string' }),
	trialEnd: timestamp("trial_end", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const verification = pgTable("verification", {
	id: text().primaryKey().notNull(),
	identifier: text().notNull(),
	value: text().notNull(),
	expiresAt: timestamp("expires_at", { mode: 'string' }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }),
	updatedAt: timestamp("updated_at", { mode: 'string' }),
});

export const user = pgTable("user", {
	id: text().primaryKey().notNull(),
	name: text().notNull(),
	email: text().notNull(),
	emailVerified: boolean("email_verified").notNull(),
	image: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	role: text(),
	banned: boolean(),
	banReason: text("ban_reason"),
	banExpires: timestamp("ban_expires", { mode: 'string' }),
	stripeCustomerId: text("stripe_customer_id"),
}, (table) => [
	unique("user_email_unique").on(table.email),
]);

export const emailAddresses = pgTable("email_addresses", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	address: varchar({ length: 255 }).notNull(),
	domainId: varchar("domain_id", { length: 255 }).notNull(),
	isActive: boolean("is_active").default(true),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	isReceiptRuleConfigured: boolean("is_receipt_rule_configured").default(false),
	receiptRuleName: varchar("receipt_rule_name", { length: 255 }),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	webhookId: varchar("webhook_id", { length: 255 }),
	endpointId: varchar("endpoint_id", { length: 255 }),
}, (table) => [
	unique("email_addresses_address_unique").on(table.address),
]);

export const receivedEmails = pgTable("received_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	messageId: varchar("message_id", { length: 255 }).notNull(),
	from: varchar({ length: 255 }).notNull(),
	to: text().notNull(),
	subject: text(),
	receivedAt: timestamp("received_at", { mode: 'string' }).notNull(),
	processedAt: timestamp("processed_at", { mode: 'string' }),
	status: varchar({ length: 50 }).notNull(),
	metadata: text(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	sesEventId: varchar("ses_event_id", { length: 255 }).notNull(),
	recipient: varchar({ length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	isRead: boolean("is_read").default(false),
	readAt: timestamp("read_at", { mode: 'string' }),
	fromParsed: text("from_parsed"),
	toParsed: text("to_parsed"),
	ccParsed: text("cc_parsed"),
	bccParsed: text("bcc_parsed"),
	replyToParsed: text("reply_to_parsed"),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	rawEmailContent: text("raw_email_content"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	priority: varchar({ length: 50 }),
	attachments: text(),
	headers: text(),
	emailDate: timestamp("email_date", { mode: 'string' }),
});

export const webhookDeliveries = pgTable("webhook_deliveries", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }),
	endpoint: varchar({ length: 500 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	attempts: integer().default(0),
	lastAttemptAt: timestamp("last_attempt_at", { mode: 'string' }),
	responseCode: integer("response_code"),
	error: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	webhookId: varchar("webhook_id", { length: 255 }).notNull(),
	payload: text(),
	responseBody: text("response_body"),
	deliveryTime: integer("delivery_time"),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const account = pgTable("account", {
	id: text().primaryKey().notNull(),
	accountId: text("account_id").notNull(),
	providerId: text("provider_id").notNull(),
	userId: text("user_id").notNull(),
	accessToken: text("access_token"),
	refreshToken: text("refresh_token"),
	idToken: text("id_token"),
	accessTokenExpiresAt: timestamp("access_token_expires_at", { mode: 'string' }),
	refreshTokenExpiresAt: timestamp("refresh_token_expires_at", { mode: 'string' }),
	scope: text(),
	password: text(),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "account_user_id_user_id_fk"
	}).onDelete("cascade"),
]);

export const domainDnsRecords = pgTable("domain_dns_records", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	domainId: varchar("domain_id", { length: 255 }).notNull(),
	recordType: varchar("record_type", { length: 10 }).notNull(),
	name: varchar({ length: 255 }).notNull(),
	value: text().notNull(),
	isRequired: boolean("is_required").default(true),
	isVerified: boolean("is_verified").default(false),
	lastChecked: timestamp("last_checked", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const sesEvents = pgTable("ses_events", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	eventSource: varchar("event_source", { length: 100 }).notNull(),
	eventVersion: varchar("event_version", { length: 50 }).notNull(),
	messageId: varchar("message_id", { length: 255 }).notNull(),
	source: varchar({ length: 255 }).notNull(),
	destination: text().notNull(),
	subject: text(),
	timestamp: timestamp({ mode: 'string' }).notNull(),
	receiptTimestamp: timestamp("receipt_timestamp", { mode: 'string' }).notNull(),
	processingTimeMillis: integer("processing_time_millis"),
	recipients: text().notNull(),
	spamVerdict: varchar("spam_verdict", { length: 50 }),
	virusVerdict: varchar("virus_verdict", { length: 50 }),
	spfVerdict: varchar("spf_verdict", { length: 50 }),
	dkimVerdict: varchar("dkim_verdict", { length: 50 }),
	dmarcVerdict: varchar("dmarc_verdict", { length: 50 }),
	actionType: varchar("action_type", { length: 50 }),
	s3BucketName: varchar("s3_bucket_name", { length: 255 }),
	s3ObjectKey: varchar("s3_object_key", { length: 500 }),
	emailContent: text("email_content"),
	s3ContentFetched: boolean("s3_content_fetched").default(false),
	s3ContentSize: integer("s3_content_size"),
	s3Error: text("s3_error"),
	commonHeaders: text("common_headers"),
	rawSesEvent: text("raw_ses_event").notNull(),
	lambdaContext: text("lambda_context"),
	webhookPayload: text("webhook_payload"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const webhooks = pgTable("webhooks", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	url: text().notNull(),
	secret: varchar({ length: 255 }),
	isActive: boolean("is_active").default(true),
	description: text(),
	headers: text(),
	timeout: integer().default(30),
	retryAttempts: integer("retry_attempts").default(3),
	lastUsed: timestamp("last_used", { mode: 'string' }),
	totalDeliveries: integer("total_deliveries").default(0),
	successfulDeliveries: integer("successful_deliveries").default(0),
	failedDeliveries: integer("failed_deliveries").default(0),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	userId: varchar("user_id", { length: 255 }).notNull(),
});

export const apikey = pgTable("apikey", {
	id: text().primaryKey().notNull(),
	name: text(),
	start: text(),
	prefix: text(),
	key: text().notNull(),
	userId: text("user_id").notNull(),
	refillInterval: integer("refill_interval"),
	refillAmount: integer("refill_amount"),
	lastRefillAt: timestamp("last_refill_at", { mode: 'string' }),
	enabled: boolean().default(true),
	rateLimitEnabled: boolean("rate_limit_enabled").default(true),
	rateLimitTimeWindow: integer("rate_limit_time_window").default(86400000),
	rateLimitMax: integer("rate_limit_max").default(10),
	requestCount: integer("request_count"),
	remaining: integer(),
	lastRequest: timestamp("last_request", { mode: 'string' }),
	expiresAt: timestamp("expires_at", { mode: 'string' }),
	createdAt: timestamp("created_at", { mode: 'string' }).notNull(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).notNull(),
	permissions: text(),
	metadata: text(),
}, (table) => [
	foreignKey({
		columns: [table.userId],
		foreignColumns: [user.id],
		name: "apikey_user_id_user_id_fk"
	}).onDelete("cascade"),
]);

export const parsedEmails = pgTable("parsed_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }).notNull(),
	messageId: varchar("message_id", { length: 255 }),
	fromText: text("from_text"),
	fromAddress: varchar("from_address", { length: 255 }),
	fromName: varchar("from_name", { length: 255 }),
	toText: text("to_text"),
	toAddresses: text("to_addresses"),
	ccText: text("cc_text"),
	ccAddresses: text("cc_addresses"),
	bccText: text("bcc_text"),
	bccAddresses: text("bcc_addresses"),
	replyToText: text("reply_to_text"),
	replyToAddresses: text("reply_to_addresses"),
	subject: text(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	priority: varchar({ length: 50 }),
	emailDate: timestamp("email_date", { mode: 'string' }),
	attachments: text(),
	attachmentCount: integer("attachment_count").default(0),
	hasAttachments: boolean("has_attachments").default(false),
	headers: text(),
	hasTextBody: boolean("has_text_body").default(false),
	hasHtmlBody: boolean("has_html_body").default(false),
	parseSuccess: boolean("parse_success").default(true),
	parseError: text("parse_error"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const structuredEmails = pgTable("structured_emails", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }).notNull(),
	sesEventId: varchar("ses_event_id", { length: 255 }).notNull(),
	messageId: varchar("message_id", { length: 255 }),
	date: timestamp({ mode: 'string' }),
	subject: text(),
	fromData: text("from_data"),
	toData: text("to_data"),
	ccData: text("cc_data"),
	bccData: text("bcc_data"),
	replyToData: text("reply_to_data"),
	inReplyTo: varchar("in_reply_to", { length: 255 }),
	references: text(),
	textBody: text("text_body"),
	htmlBody: text("html_body"),
	rawContent: text("raw_content"),
	attachments: text(),
	headers: text(),
	priority: varchar({ length: 50 }),
	parseSuccess: boolean("parse_success").default(true),
	parseError: text("parse_error"),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
	isRead: boolean("is_read").default(false),
	readAt: timestamp("read_at", { mode: 'string' }),
});

export const endpoints = pgTable("endpoints", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	name: varchar({ length: 255 }).notNull(),
	type: varchar({ length: 50 }).notNull(),
	config: text().notNull(),
	isActive: boolean("is_active").default(true),
	description: text(),
	userId: varchar("user_id", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});

export const emailGroups = pgTable("email_groups", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	endpointId: varchar("endpoint_id", { length: 255 }).notNull(),
	emailAddress: varchar("email_address", { length: 255 }).notNull(),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
});

export const endpointDeliveries = pgTable("endpoint_deliveries", {
	id: varchar({ length: 255 }).primaryKey().notNull(),
	emailId: varchar("email_id", { length: 255 }),
	endpointId: varchar("endpoint_id", { length: 255 }).notNull(),
	deliveryType: varchar("delivery_type", { length: 50 }).notNull(),
	status: varchar({ length: 50 }).notNull(),
	attempts: integer().default(0),
	lastAttemptAt: timestamp("last_attempt_at", { mode: 'string' }),
	responseData: text("response_data"),
	createdAt: timestamp("created_at", { mode: 'string' }).defaultNow(),
	updatedAt: timestamp("updated_at", { mode: 'string' }).defaultNow(),
});
