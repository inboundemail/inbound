{"version":3,"sources":["turbopack:///[project]/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server-edge.ts","turbopack:///[project]/node_modules/deepmerge/dist/cjs.js","turbopack:///[project]/lib/email-management/email-parser.ts","turbopack:///[project]/app/api/v2/mail/[id]/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["module.exports = require('../../module.compiled').vendored[\n  'react-rsc'\n].ReactServerDOMTurbopackServerEdge\n","'use strict';\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn Object.propertyIsEnumerable.call(target, symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n","/**\n * Core email parsing utilities using mailparser for processing raw email content.\n * Provides the main parseEmail function for converting raw email strings into structured ParsedEmailData objects.\n * Used extensively throughout the application for webhook processing, email routing, and data storage.\n * Includes HTML sanitization and type definitions for consistent email data handling.\n */\nimport { simpleParser, ParsedMail, Attachment } from 'mailparser'\n\n// Types for the parsed email data structure\ninterface ParsedEmailAddress {\n  text: string\n  addresses: Array<{\n    name: string | null\n    address: string | null\n  }>\n}\n\n// Header value types for complex header structures\ninterface ParsedEmailHeaderValue {\n  value?: Array<{\n    address: string\n    name: string\n  }> | string\n  html?: string\n  text?: string\n  params?: Record<string, string>\n}\n\ninterface ParsedEmailListHeader {\n  unsubscribe?: {\n    url: string\n  }\n  'unsubscribe-post'?: {\n    name: string\n  }\n}\n\ninterface ParsedEmailData {\n  messageId: string | undefined\n  date: Date | undefined\n  subject: string | undefined\n  from: ParsedEmailAddress | null\n  to: ParsedEmailAddress | null\n  cc: ParsedEmailAddress | null\n  bcc: ParsedEmailAddress | null\n  replyTo: ParsedEmailAddress | null\n  inReplyTo: string | undefined\n  references: string[] | undefined\n  textBody: string | undefined\n  htmlBody: string | undefined\n  raw?: string\n  attachments: Array<{\n    filename: string | undefined\n    contentType: string | undefined\n    size: number | undefined\n    contentId: string | undefined\n    contentDisposition: string | undefined\n  }>\n  headers: Record<string, any> & {\n    'return-path'?: ParsedEmailHeaderValue\n    'received'?: string | string[]\n    'received-spf'?: string\n    'authentication-results'?: string\n    'x-ses-receipt'?: string\n    'x-ses-dkim-signature'?: string\n    'dkim-signature'?: Array<{\n      value: string\n      params: Record<string, string>\n    }> | ParsedEmailHeaderValue\n    'list'?: ParsedEmailListHeader\n    'x-entity-ref-id'?: string\n    'from'?: ParsedEmailHeaderValue\n    'to'?: ParsedEmailHeaderValue\n    'subject'?: string\n    'message-id'?: string\n    'date'?: string\n    'mime-version'?: string\n    'content-type'?: {\n      value: string\n      params: Record<string, string>\n    }\n    'feedback-id'?: string\n    'x-ses-outgoing'?: string\n  }\n  priority: string | false | undefined\n}\n\nexport async function parseEmail(emailContent: string): Promise<ParsedEmailData> {\n  try {\n    // Parse the email\n    const parsed = await simpleParser(emailContent);\n    \n    // Helper function to extract address info\n    const extractAddressInfo = (addressObj: any): ParsedEmailAddress | null => {\n      if (!addressObj) return null;\n      \n      if (Array.isArray(addressObj)) {\n        return {\n          text: addressObj.map(addr => addr.text || `${addr.name || ''} <${addr.address || ''}>`).join(', '),\n          addresses: addressObj.map(addr => ({\n            name: addr.name || null,\n            address: addr.address || null\n          }))\n        };\n      } else if (addressObj.value && Array.isArray(addressObj.value)) {\n        // Handle AddressObject with value array\n        return {\n          text: addressObj.text,\n          addresses: addressObj.value.map((addr: any) => ({\n            name: addr.name || null,\n            address: addr.address || null\n          }))\n        };\n      } else if (addressObj.value) {\n        // Handle AddressObject with single value\n        return {\n          text: addressObj.text,\n          addresses: [{\n            name: addressObj.value.name || null,\n            address: addressObj.value.address || null\n          }]\n        };\n      } else {\n        // Handle direct address object\n        return {\n          text: addressObj.text || `${addressObj.name || ''} <${addressObj.address || ''}>`,\n          addresses: [{\n            name: addressObj.name || null,\n            address: addressObj.address || null\n          }]\n        };\n      }\n    };\n    \n    // Extract key information\n    const emailData: ParsedEmailData = {\n      messageId: parsed.messageId,\n      date: parsed.date,\n      subject: parsed.subject,\n      from: extractAddressInfo(parsed.from),\n      to: extractAddressInfo(parsed.to),\n      cc: extractAddressInfo(parsed.cc),\n      bcc: extractAddressInfo(parsed.bcc),\n      replyTo: extractAddressInfo(parsed.replyTo),\n      inReplyTo: parsed.inReplyTo,\n      references: Array.isArray(parsed.references) ? parsed.references : parsed.references ? [parsed.references] : undefined,\n      textBody: parsed.text,\n      htmlBody: parsed.html || undefined,\n      raw: emailContent,\n      attachments: parsed.attachments?.map(att => ({\n        filename: att.filename,\n        contentType: att.contentType,\n        size: att.size,\n        contentId: att.contentId,\n        contentDisposition: att.contentDisposition\n      })) || [],\n      headers: Object.fromEntries(parsed.headers),\n      priority: parsed.priority\n    };\n    \n    // Return the full parsed data for programmatic use\n    return emailData;\n    \n  } catch (error) {\n    console.error('Error parsing email:', error);\n    throw error;\n  }\n}\n\n// Legacy interface for backward compatibility\ninterface ParsedEmail {\n  headers: Record<string, string>\n  htmlBody: string | null\n  textBody: string | null\n  attachments: Array<{\n    filename: string\n    contentType: string\n    size: number\n    contentId?: string\n    isInline?: boolean\n  }>\n}\n\n// Process inline images by converting Content-ID references to data URLs\nfunction processInlineImages(html: string, attachments: Attachment[]): string {\n  if (!html || !attachments) return html\n\n  let processedHtml = html\n\n  // Create a map of Content-ID to attachment data\n  const cidMap = new Map<string, string>()\n  \n  for (const attachment of attachments) {\n    if (attachment.contentId && attachment.content) {\n      // Remove angle brackets from Content-ID if present\n      const cleanCid = attachment.contentId.replace(/^<|>$/g, '')\n      \n      // Convert attachment content to base64 data URL\n      const base64Data = attachment.content.toString('base64')\n      const dataUrl = `data:${attachment.contentType || 'application/octet-stream'};base64,${base64Data}`\n      \n      cidMap.set(cleanCid, dataUrl)\n    }\n  }\n\n  // Replace Content-ID references in HTML\n  for (const [cid, dataUrl] of cidMap) {\n    // Replace various formats of Content-ID references\n    const patterns = [\n      new RegExp(`src-cid=[\"']${cid}[\"']`, 'gi'),\n      new RegExp(`src=[\"']cid:${cid}[\"']`, 'gi'),\n      new RegExp(`src=[\"']${cid}[\"']`, 'gi'),\n    ]\n\n    for (const pattern of patterns) {\n      processedHtml = processedHtml.replace(pattern, `src=\"${dataUrl}\"`)\n    }\n  }\n\n  return processedHtml\n}\n\nexport function sanitizeHtml(html: string): string {\n  if (!html) return ''\n  \n  // Basic HTML sanitization - remove script tags and dangerous attributes\n  // Allow data: URLs for images but be restrictive about other uses\n  return html\n    .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, '')\n    .replace(/on\\w+=\"[^\"]*\"/gi, '')\n    .replace(/on\\w+='[^']*'/gi, '')\n    .replace(/javascript:/gi, '')\n    .replace(/vbscript:/gi, '')\n    // Only remove data: URLs that are NOT for images\n    .replace(/(?<!src=[\"'])data:(?!image\\/)/gi, '')\n}\n\nexport function extractEmailDomain(email: string): string {\n  const match = email.match(/@([^>]+)/)\n  return match ? match[1] : ''\n}\n\nexport function formatEmailAddress(email: string): { name: string; address: string } {\n  // Handle formats like \"Name <email@domain.com>\" or just \"email@domain.com\"\n  const match = email.match(/^(.+?)\\s*<(.+?)>$/)\n  if (match) {\n    return {\n      name: match[1].replace(/['\"]/g, '').trim(),\n      address: match[2].trim()\n    }\n  }\n  \n  return {\n    name: '',\n    address: email.trim()\n  }\n}\n\n/**\n * Extract a single email address from various address object formats (mailparser AddressObject)\n * Handles string, AddressObject, and array formats commonly returned by mailparser\n */\nexport function extractEmailAddress(addressObj: any): string {\n  if (!addressObj) return 'unknown'\n  if (typeof addressObj === 'string') return addressObj\n  if (addressObj.text) return addressObj.text\n  if (Array.isArray(addressObj) && addressObj.length > 0) {\n    return addressObj[0].text || addressObj[0].address || 'unknown'\n  }\n  if (addressObj.address) return addressObj.address\n  if (addressObj.name) return addressObj.name\n  return 'unknown'\n}\n\n/**\n * Extract multiple email addresses from various address object formats (mailparser AddressObject)\n * Returns an array of email address strings\n */\nexport function extractEmailAddresses(addressObj: any): string[] {\n  if (!addressObj) return []\n  if (typeof addressObj === 'string') return [addressObj]\n  if (Array.isArray(addressObj)) {\n    return addressObj.map(addr => addr.text || addr.address || 'unknown')\n  }\n  if (addressObj.text) return [addressObj.text]\n  if (addressObj.address) return [addressObj.address]\n  return []\n}\n\n// Export the ParsedEmailData type for use in other files\nexport type { ParsedEmailData, ParsedEmailAddress, ParsedEmailHeaderValue, ParsedEmailListHeader } ","import { NextRequest, NextResponse } from 'next/server'\nimport { headers } from 'next/headers'\nimport { auth } from '@/lib/auth/auth'\nimport { getEmail, updateEmail } from '@/functions/mail/primary'\nimport { validateRequest } from '../../helper/main'\n\n\n// GET /api/v2/mail/[id] types\nexport interface GetMailByIdParams {\n    id: string\n}\n\nexport interface ParsedEmailAddress {\n    text: string\n    addresses: Array<{\n        name: string | null\n        address: string | null\n    }>\n}\n\nexport interface EmailAttachment {\n    filename: string | undefined\n    contentType: string | undefined\n    size: number | undefined\n    contentId: string | undefined\n    contentDisposition: string | undefined\n}\n\nexport interface GetMailByIdResponse {\n    id: string\n    emailId: string\n    messageId: string | null\n    subject: string | null\n    from: string\n    fromName: string | null\n    to: string\n    cc: string | null\n    bcc: string | null\n    replyTo: string | null\n    recipient: string\n    receivedAt: Date | null\n    isRead: boolean\n    readAt: Date | null\n    \n    content: {\n        textBody: string | null\n        htmlBody: string | null\n        rawContent: string | null\n        attachments: EmailAttachment[]\n        headers: Record<string, any>\n    }\n    \n    addresses: {\n        from: ParsedEmailAddress | null\n        to: ParsedEmailAddress | null\n        cc: ParsedEmailAddress | null\n        bcc: ParsedEmailAddress | null\n        replyTo: ParsedEmailAddress | null\n    }\n    \n    metadata: {\n        inReplyTo: string | null\n        references: string[]\n        priority: string | null\n        parseSuccess: boolean | null\n        parseError: string | null\n        hasAttachments: boolean\n        attachmentCount: number\n        hasTextBody: boolean\n        hasHtmlBody: boolean\n    }\n    \n    security: {\n        spf: string\n        dkim: string\n        dmarc: string\n        spam: string\n        virus: string\n    }\n    \n    processing: {\n        processingTimeMs: number | null\n        timestamp: Date | null\n        receiptTimestamp: Date | null\n        actionType: string | null\n        s3Info: {\n            bucketName: string | null\n            objectKey: string | null\n            contentFetched: boolean | null\n            contentSize: number | null\n            error: string | null\n        }\n        commonHeaders: Record<string, any> | null\n    }\n    \n    createdAt: Date | null\n    updatedAt: Date | null\n}\n\n/**\n * GET /api/v2/mail/[id]\n * Gets a single email by id (returns the entire email object)\n * Supports both session-based auth and API key auth\n * Has tests? ‚úÖ\n * Has logging? ‚úÖ\n * Has types? ‚úÖ\n */\nexport async function GET(\n    request: NextRequest,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    console.log('üìß GET /api/v2/mail/[id] - Starting request')\n    \n    try {\n        // Get session (handles both regular sessions and API key sessions)\n        console.log('üîê Validating request authentication')\n        const { userId, error } = await validateRequest(request)\n        if (!userId) {\n            console.log('‚ùå Authentication failed:', error)\n            return NextResponse.json(\n                { error: error },\n                { status: 401 }\n            )\n        }\n        console.log('‚úÖ Authentication successful for userId:', userId)\n        \n        const { id } = await params\n        console.log('üì® Requested email ID:', id)\n\n        // Validate email ID\n        if (!id || typeof id !== 'string') {\n            console.log('‚ö†Ô∏è Invalid email ID provided:', id)\n            return NextResponse.json(\n                { error: 'Valid email ID is required' },\n                { status: 400 }\n            )\n        }\n\n        // Call the function with userId\n        console.log('üîç Calling getEmail function for userId:', userId, 'emailId:', id)\n        const result = await getEmail(userId, id)\n\n        if (result.error) {\n            if (result.error === 'Email not found') {\n                console.log('üì≠ Email not found for user:', userId, 'emailId:', id)\n                return NextResponse.json(\n                    { error: 'Email not found' },\n                    { status: 404 }\n                )\n            }\n            console.log('üí• getEmail returned error:', result.error)\n            return NextResponse.json(\n                { error: result.error },\n                { status: 500 }\n            )\n        }\n\n        console.log('‚úÖ Successfully retrieved email for user:', userId, 'emailId:', id)\n        return NextResponse.json(result.data)\n\n    } catch (error) {\n        console.error('üí• Unexpected error in GET /api/v2/mail/[id]:', error)\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        )\n    }\n}\n\n/**\n * PATCH /api/v2/mail/[id]\n * Updates email properties (read status, archive status, etc.)\n * Supports both session-based auth and API key auth\n * Has tests? ‚ùå\n * Has logging? ‚úÖ\n * Has types? ‚úÖ\n */\n\n// PATCH /api/v2/mail/[id] types\nexport interface PatchMailRequest {\n    isRead?: boolean\n    isArchived?: boolean\n}\n\nexport interface PatchMailResponse {\n    id: string\n    isRead: boolean\n    isArchived: boolean\n    readAt: Date | null\n    archivedAt: Date | null\n}\n\nexport async function PATCH(\n    request: NextRequest,\n    { params }: { params: Promise<{ id: string }> }\n) {\n    console.log('‚úèÔ∏è PATCH /api/v2/mail/[id] - Starting update request')\n    \n    try {\n        console.log('üîê Validating request authentication')\n        const { userId, error } = await validateRequest(request)\n        if (!userId) {\n            console.log('‚ùå Authentication failed:', error)\n            return NextResponse.json(\n                { error: error },\n                { status: 401 }\n            )\n        }\n        console.log('‚úÖ Authentication successful for userId:', userId)\n        \n        const { id } = await params\n        console.log('üì® Updating email ID:', id)\n\n        // Validate email ID\n        if (!id || typeof id !== 'string') {\n            console.log('‚ö†Ô∏è Invalid email ID provided:', id)\n            return NextResponse.json(\n                { error: 'Valid email ID is required' },\n                { status: 400 }\n            )\n        }\n\n        console.log('üìù Parsing request body')\n        const body = await request.json()\n        console.log('üìã Update data received:', body)\n\n        // Validate request body\n        if (typeof body.isRead !== 'undefined' && typeof body.isRead !== 'boolean') {\n            return NextResponse.json(\n                { error: 'isRead must be a boolean' },\n                { status: 400 }\n            )\n        }\n\n        if (typeof body.isArchived !== 'undefined' && typeof body.isArchived !== 'boolean') {\n            return NextResponse.json(\n                { error: 'isArchived must be a boolean' },\n                { status: 400 }\n            )\n        }\n\n        if (!body.isRead && !body.isArchived && body.isRead !== false && body.isArchived !== false) {\n            return NextResponse.json(\n                { error: 'At least one field (isRead or isArchived) must be provided' },\n                { status: 400 }\n            )\n        }\n\n        // Call the update function\n        console.log('üîÑ Calling updateEmail function for userId:', userId, 'emailId:', id)\n        const result = await updateEmail(userId, id, {\n            isRead: body.isRead,\n            isArchived: body.isArchived\n        })\n\n        if (result.error) {\n            if (result.error === 'Email not found or access denied') {\n                console.log('üì≠ Email not found for user:', userId, 'emailId:', id)\n                return NextResponse.json(\n                    { error: 'Email not found' },\n                    { status: 404 }\n                )\n            }\n            console.log('üí• updateEmail returned error:', result.error)\n            return NextResponse.json(\n                { error: result.error },\n                { status: 500 }\n            )\n        }\n\n        console.log('‚úÖ Successfully updated email for user:', userId, 'emailId:', id)\n        return NextResponse.json(result.data)\n\n    } catch (error) {\n        console.error('üí• Unexpected error in PATCH /api/v2/mail/[id]:', error)\n        return NextResponse.json(\n            { error: 'Internal server error' },\n            { status: 500 }\n        )\n    }\n} ","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["module","exports","require","vendored","ReactServerDOMTurbopackServerEdge","AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[0,1,4]}