{"version":3,"sources":["turbopack:///[project]/lib/email-management/email-blocking.ts","turbopack:///[project]/components/email-banner.tsx","turbopack:///[project]/lib/email-management/email-forwarder.ts","turbopack:///[project]/lib/email-management/email-router.ts","turbopack:///[project]/app/api/inbound/webhook/route.ts","turbopack:///[project]/node_modules/next/dist/src/build/templates/app-route.ts"],"sourcesContent":["import { db } from '@/lib/db'\nimport { blockedEmails, emailDomains, emailAddresses } from '@/lib/db/schema'\nimport { eq, and } from 'drizzle-orm'\nimport { nanoid } from 'nanoid'\n\n/**\n * Extract domain from email address\n */\nfunction extractDomain(email: string): string {\n  return email.split('@')[1]?.toLowerCase() || ''\n}\n\n/**\n * Check if an email address is already blocked\n */\nexport async function isEmailBlocked(emailAddress: string): Promise<boolean> {\n  try {\n    const blocked = await db\n      .select({ id: blockedEmails.id })\n      .from(blockedEmails)\n      .where(eq(blockedEmails.emailAddress, emailAddress.toLowerCase()))\n      .limit(1)\n\n    return blocked.length > 0\n  } catch (error) {\n    console.error('Error checking if email is blocked:', error)\n    return false\n  }\n}\n\n/**\n * Block an email address if it's on a catch-all domain\n * This function only blocks emails from catch-all domains, not manually added email addresses\n */\nexport async function blockEmail(\n  emailAddress: string, \n  blockedBy: string, \n  reason?: string\n): Promise<{ success: boolean; error?: string; message?: string }> {\n  try {\n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(emailAddress)) {\n      return {\n        success: false,\n        error: 'Invalid email format'\n      }\n    }\n\n    const normalizedEmail = emailAddress.toLowerCase()\n    const domain = extractDomain(normalizedEmail)\n\n    if (!domain) {\n      return {\n        success: false,\n        error: 'Could not extract domain from email address'\n      }\n    }\n\n    // Check if email is already blocked\n    const alreadyBlocked = await isEmailBlocked(normalizedEmail)\n    if (alreadyBlocked) {\n      return {\n        success: false,\n        error: 'Email address is already blocked'\n      }\n    }\n\n    // Look up the domain to check if it exists and is catch-all\n    const domainRecord = await db\n      .select({\n        id: emailDomains.id,\n        domain: emailDomains.domain,\n        isCatchAllEnabled: emailDomains.isCatchAllEnabled,\n        userId: emailDomains.userId\n      })\n      .from(emailDomains)\n      .where(eq(emailDomains.domain, domain))\n      .limit(1)\n\n    if (!domainRecord[0]) {\n      return {\n        success: false,\n        error: `Domain ${domain} not found in the system`\n      }\n    }\n\n    const domainData = domainRecord[0]\n\n    // Check if this is a manually added email address (not catch-all)\n    const manualEmailRecord = await db\n      .select({ id: emailAddresses.id })\n      .from(emailAddresses)\n      .where(and(\n        eq(emailAddresses.address, normalizedEmail),\n        eq(emailAddresses.domainId, domainData.id)\n      ))\n      .limit(1)\n\n    if (manualEmailRecord[0]) {\n      return {\n        success: false,\n        error: 'Cannot block manually added email addresses. Only catch-all emails can be blocked.'\n      }\n    }\n\n    // Check if domain has catch-all enabled\n    if (!domainData.isCatchAllEnabled) {\n      return {\n        success: false,\n        error: `Domain ${domain} does not have catch-all enabled. Only emails from catch-all domains can be blocked.`\n      }\n    }\n\n    // Create the blocked email record\n    const blockedEmailRecord = {\n      id: nanoid(),\n      emailAddress: normalizedEmail,\n      domainId: domainData.id,\n      reason: reason || null,\n      blockedBy: blockedBy,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    }\n\n    await db.insert(blockedEmails).values(blockedEmailRecord)\n\n    console.log(`‚úÖ Email blocking - Successfully blocked ${normalizedEmail} on catch-all domain ${domain}`)\n\n    return {\n      success: true,\n      message: `Successfully blocked ${normalizedEmail} from catch-all domain ${domain}`\n    }\n\n  } catch (error) {\n    console.error('Error blocking email:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred while blocking email'\n    }\n  }\n}\n\n/**\n * Unblock an email address\n */\nexport async function unblockEmail(\n  emailAddress: string\n): Promise<{ success: boolean; error?: string; message?: string }> {\n  try {\n    const normalizedEmail = emailAddress.toLowerCase()\n\n    // Check if email is blocked\n    const blockedRecord = await db\n      .select({ id: blockedEmails.id })\n      .from(blockedEmails)\n      .where(eq(blockedEmails.emailAddress, normalizedEmail))\n      .limit(1)\n\n    if (!blockedRecord[0]) {\n      return {\n        success: false,\n        error: 'Email address is not blocked'\n      }\n    }\n\n    // Remove from blocked list\n    await db\n      .delete(blockedEmails)\n      .where(eq(blockedEmails.emailAddress, normalizedEmail))\n\n    console.log(`‚úÖ Email blocking - Successfully unblocked ${normalizedEmail}`)\n\n    return {\n      success: true,\n      message: `Successfully unblocked ${normalizedEmail}`\n    }\n\n  } catch (error) {\n    console.error('Error unblocking email:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred while unblocking email'\n    }\n  }\n}\n\n/**\n * Get all blocked emails for a domain\n */\nexport async function getBlockedEmailsForDomain(domainId: string): Promise<{\n  success: boolean\n  blockedEmails?: Array<{\n    id: string\n    emailAddress: string\n    reason: string | null\n    blockedBy: string\n    createdAt: Date | null\n  }>\n  error?: string\n}> {\n  try {\n    const blocked = await db\n      .select({\n        id: blockedEmails.id,\n        emailAddress: blockedEmails.emailAddress,\n        reason: blockedEmails.reason,\n        blockedBy: blockedEmails.blockedBy,\n        createdAt: blockedEmails.createdAt\n      })\n      .from(blockedEmails)\n      .where(eq(blockedEmails.domainId, domainId))\n\n    return {\n      success: true,\n      blockedEmails: blocked\n    }\n\n  } catch (error) {\n    console.error('Error getting blocked emails for domain:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\n    }\n  }\n}\n\n/**\n * Get all blocked emails for a user (across all their domains)\n */\nexport async function getBlockedEmailsForUser(userId: string): Promise<{\n  success: boolean\n  blockedEmails?: Array<{\n    id: string\n    emailAddress: string\n    domain: string\n    reason: string | null\n    blockedBy: string\n    createdAt: Date | null\n  }>\n  error?: string\n}> {\n  try {\n    const blocked = await db\n      .select({\n        id: blockedEmails.id,\n        emailAddress: blockedEmails.emailAddress,\n        domain: emailDomains.domain,\n        reason: blockedEmails.reason,\n        blockedBy: blockedEmails.blockedBy,\n        createdAt: blockedEmails.createdAt\n      })\n      .from(blockedEmails)\n      .innerJoin(emailDomains, eq(blockedEmails.domainId, emailDomains.id))\n      .where(eq(emailDomains.userId, userId))\n\n    return {\n      success: true,\n      blockedEmails: blocked\n    }\n\n  } catch (error) {\n    console.error('Error getting blocked emails for user:', error)\n    return {\n      success: false,\n      error: error instanceof Error ? error.message : 'Unknown error occurred'\n    }\n  }\n} ","import React from 'react'\nimport { Button } from '@/components/ui/button'\n\ninterface EmailBannerProps {\n  recipientEmail: string\n  senderEmail: string\n  className?: string\n}\n\nexport function EmailBanner({ recipientEmail, senderEmail, className = '' }: EmailBannerProps) {\n  const blockUrl = `https://inbound.new/addtoblocklist?email=${encodeURIComponent(recipientEmail)}`\n\n  return (\n    <div className={`text-center my-5 px-2.5 py-2 text-xs text-gray-500 border-t border-gray-200 ${className}`}>\n      sent via{' '}\n      <a \n        href=\"https://inbound.new\" \n        className=\"text-purple-500 hover:text-purple-600 no-underline\"\n      >\n        inbound.new\n      </a>\n      ,{' '}\n      <a \n        href={blockUrl}\n        target=\"_blank\"\n        rel=\"noopener noreferrer\"\n        className=\"text-purple-500 hover:text-purple-600 no-underline\"\n      >\n        block {recipientEmail}\n      </a>\n    </div>\n  )\n}\n\n// HTML version for email templates\nexport function generateEmailBannerHTML(recipientEmail: string, senderEmail: string): string {\n  const blockUrl = `https://inbound.new/addtoblocklist?email=${encodeURIComponent(recipientEmail)}`\n  \n  return `\n    <div style=\"\n      text-align: center;\n      margin: 20px 0;\n      padding: 10px;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n      font-size: 12px;\n      color: #6b7280;\n      border-top: 1px solid #e5e7eb;\n    \">\n      sent via <a href=\"https://inbound.new\" style=\"color: #8b5cf6; text-decoration: none;\">inbound.new</a>, <a href=\"${blockUrl}\" target=\"_blank\" rel=\"noopener noreferrer\" style=\"color: #8b5cf6; text-decoration: none;\">block ${recipientEmail}</a>\n    </div>\n  `\n} ","import { SESClient, SendRawEmailCommand } from '@aws-sdk/client-ses'\nimport type { ParsedEmailData } from './email-parser'\nimport { generateEmailBannerHTML } from '@/components/email-banner'\n\nexport class EmailForwarder {\n  private sesClient: SESClient\n\n  constructor() {\n    this.sesClient = new SESClient({ \n      region: process.env.AWS_REGION || 'us-east-2' \n    })\n  }\n\n  async forwardEmail(\n    originalEmail: ParsedEmailData,\n    fromAddress: string,\n    toAddresses: string[],\n    options?: {\n      subjectPrefix?: string\n      includeAttachments?: boolean\n      recipientEmail?: string // The original recipient email (e.g., user@domain.com)\n    }\n  ): Promise<void> {\n    console.log(`üì® EmailForwarder - Forwarding email from ${fromAddress} to ${toAddresses.length} recipients`)\n\n    // Build email subject with optional prefix\n    const subject = options?.subjectPrefix \n      ? `${options.subjectPrefix}${originalEmail.subject || 'No Subject'}`\n      : originalEmail.subject || 'No Subject'\n\n    // Create raw email message maintaining original structure\n    const rawMessage = await this.buildRawEmailMessage({\n      from: fromAddress,\n      to: toAddresses,\n      replyTo: originalEmail.from?.addresses?.[0]?.address || fromAddress,\n      subject,\n      originalEmail,\n      includeAttachments: options?.includeAttachments ?? true,\n      recipientEmail: options?.recipientEmail\n    })\n\n    console.log(`üì§ EmailForwarder - Sending email message (${rawMessage.length} bytes) with ${originalEmail.htmlBody ? 'HTML' : 'text'} content and ${originalEmail.attachments?.length || 0} attachments`)\n\n    const command = new SendRawEmailCommand({\n      RawMessage: {\n        Data: Buffer.from(rawMessage)\n      },\n      Source: fromAddress,\n      Destinations: toAddresses\n    })\n\n    try {\n      const result = await this.sesClient.send(command)\n      console.log(`‚úÖ EmailForwarder - Successfully forwarded email to ${toAddresses.length} recipients`, {\n        messageId: result.MessageId,\n        toAddresses,\n        attachmentCount: originalEmail.attachments?.length || 0\n      })\n    } catch (error) {\n      console.error(`‚ùå EmailForwarder - Failed to forward email:`, error)\n      throw new Error(`Email forwarding failed: ${error instanceof Error ? error.message : 'Unknown error'}`)\n    }\n  }\n\n  private async buildRawEmailMessage(params: {\n    from: string\n    to: string[]\n    replyTo: string\n    subject: string\n    originalEmail: ParsedEmailData\n    includeAttachments: boolean\n    recipientEmail?: string\n  }): Promise<string> {\n    // Generate a boundary for multipart messages\n    const boundary = `----=_NextPart_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n    \n    // Build RFC 2822 compliant email headers\n    const headers = [\n      `From: ${params.from}`,\n      `To: ${params.to.join(', ')}`,\n      `Reply-To: ${params.replyTo}`,\n      `Subject: ${this.encodeSubject(params.subject)}`,\n      `Date: ${new Date().toUTCString()}`,\n      `MIME-Version: 1.0`,\n    ]\n\n    // Add original message headers for threading (if available)\n    if (params.originalEmail.messageId) {\n      headers.push(`In-Reply-To: ${params.originalEmail.messageId}`)\n    }\n    if (params.originalEmail.references?.length) {\n      headers.push(`References: ${params.originalEmail.references.join(' ')}`)\n    }\n\n    // Check if we need multipart (attachments or both HTML and text)\n    const hasAttachments = params.includeAttachments && params.originalEmail.attachments && params.originalEmail.attachments.length > 0\n    const hasHtml = !!params.originalEmail.htmlBody\n    const hasText = !!params.originalEmail.textBody\n    const needsMultipart = hasAttachments || (hasHtml && hasText)\n\n    if (!needsMultipart) {\n      // Simple single-part message\n      if (hasHtml) {\n        headers.push('Content-Type: text/html; charset=UTF-8')\n        headers.push('Content-Transfer-Encoding: 8bit')\n        const htmlWithBanner = this.addBannerToHtml(params.originalEmail.htmlBody || '', params)\n        return [...headers, '', htmlWithBanner].join('\\r\\n')\n      } else if (hasText) {\n        headers.push('Content-Type: text/plain; charset=UTF-8')\n        headers.push('Content-Transfer-Encoding: 8bit')\n        const textWithBanner = this.addBannerToText(params.originalEmail.textBody || '', params)\n        return [...headers, '', textWithBanner].join('\\r\\n')\n      } else {\n        headers.push('Content-Type: text/plain; charset=UTF-8')\n        headers.push('Content-Transfer-Encoding: 8bit')\n        return [...headers, '', '[This email has no content]'].join('\\r\\n')\n      }\n    }\n\n    // Multipart message\n    headers.push(`Content-Type: multipart/mixed; boundary=\"${boundary}\"`)\n\n    const messageParts = [\n      ...headers,\n      '',\n      'This is a multi-part message in MIME format.',\n      ''\n    ]\n\n    // Add text/HTML content part(s)\n    if (hasHtml && hasText) {\n      // Both HTML and text - create multipart/alternative for the body\n      const altBoundary = `----=_NextPart_Alt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n      \n      messageParts.push(\n        `--${boundary}`,\n        `Content-Type: multipart/alternative; boundary=\"${altBoundary}\"`,\n        '',\n        `--${altBoundary}`,\n        'Content-Type: text/plain; charset=UTF-8',\n        'Content-Transfer-Encoding: 8bit',\n        '',\n        this.addBannerToText(params.originalEmail.textBody || '', params),\n        '',\n        `--${altBoundary}`,\n        'Content-Type: text/html; charset=UTF-8',\n        'Content-Transfer-Encoding: 8bit',\n        '',\n        this.addBannerToHtml(params.originalEmail.htmlBody || '', params),\n        '',\n        `--${altBoundary}--`,\n        ''\n      )\n    } else if (hasHtml) {\n      messageParts.push(\n        `--${boundary}`,\n        'Content-Type: text/html; charset=UTF-8',\n        'Content-Transfer-Encoding: 8bit',\n        '',\n        this.addBannerToHtml(params.originalEmail.htmlBody || '', params),\n        ''\n      )\n    } else if (hasText) {\n      messageParts.push(\n        `--${boundary}`,\n        'Content-Type: text/plain; charset=UTF-8',\n        'Content-Transfer-Encoding: 8bit',\n        '',\n        this.addBannerToText(params.originalEmail.textBody || '', params),\n        ''\n      )\n    } else {\n      messageParts.push(\n        `--${boundary}`,\n        'Content-Type: text/plain; charset=UTF-8',\n        'Content-Transfer-Encoding: 8bit',\n        '',\n        '[This email has no content]',\n        ''\n      )\n    }\n\n    // Add attachments if requested\n    if (hasAttachments) {\n      console.log(`üìé EmailForwarder - Including ${params.originalEmail.attachments!.length} attachments in forwarded email`)\n      \n      for (const attachment of params.originalEmail.attachments!) {\n        if (!attachment.filename) {\n          console.warn(`‚ö†Ô∏è EmailForwarder - Skipping attachment without filename`)\n          continue\n        }\n\n        // Get attachment content from the structured email data\n        const attachmentContent = await this.getAttachmentContent(params.originalEmail, attachment.filename)\n        \n        if (!attachmentContent) {\n          console.warn(`‚ö†Ô∏è EmailForwarder - Could not retrieve content for attachment: ${attachment.filename}`)\n          continue\n        }\n\n        messageParts.push(\n          `--${boundary}`,\n          `Content-Type: ${attachment.contentType || 'application/octet-stream'}`,\n          `Content-Transfer-Encoding: base64`,\n          `Content-Disposition: attachment; filename=\"${this.encodeFilename(attachment.filename)}\"`,\n          ''\n        )\n\n        // Split base64 content into 76-character lines (RFC 2045)\n        const base64Content = Buffer.from(attachmentContent).toString('base64')\n        const lines = base64Content.match(/.{1,76}/g) || []\n        messageParts.push(...lines, '')\n      }\n    }\n\n    // Close the multipart message\n    messageParts.push(`--${boundary}--`)\n\n    return messageParts.join('\\r\\n')\n  }\n\n  /**\n   * Get attachment content from the original email\n   * This is a simplified version - in a real implementation you might need to\n   * fetch from S3 or parse the raw email content again\n   */\n  private async getAttachmentContent(originalEmail: ParsedEmailData, filename: string): Promise<Buffer | null> {\n    try {\n      // If we have the raw email content, parse it to get attachment content\n      if (originalEmail.raw) {\n        const { simpleParser } = await import('mailparser')\n        const parsed = await simpleParser(originalEmail.raw)\n        \n        const attachment = parsed.attachments?.find(att => att.filename === filename)\n        if (attachment && attachment.content) {\n          return attachment.content\n        }\n      }\n\n      // If no raw content available, we can't include the attachment\n      console.warn(`‚ö†Ô∏è EmailForwarder - No raw email content available to extract attachment: ${filename}`)\n      return null\n    } catch (error) {\n      console.error(`‚ùå EmailForwarder - Error extracting attachment ${filename}:`, error)\n      return null\n    }\n  }\n\n  /**\n   * Encode email subject to handle special characters\n   */\n  private encodeSubject(subject: string): string {\n    // Basic implementation - in production you might want to use proper RFC 2047 encoding\n    return subject.replace(/[\\r\\n]/g, ' ').trim()\n  }\n\n  /**\n   * Encode filename for Content-Disposition header\n   */\n  private encodeFilename(filename: string): string {\n    // Basic filename encoding - escape quotes and handle special characters\n    return filename.replace(/\"/g, '\\\\\"')\n  }\n\n  /**\n   * Convert HTML to plain text (basic implementation)\n   */\n  private htmlToText(html: string): string {\n    return html\n      .replace(/<br\\s*\\/?>/gi, '\\n')\n      .replace(/<\\/p>/gi, '\\n\\n')\n      .replace(/<[^>]*>/g, '')\n      .replace(/&nbsp;/g, ' ')\n      .replace(/&lt;/g, '<')\n      .replace(/&gt;/g, '>')\n      .replace(/&amp;/g, '&')\n      .trim()\n  }\n\n  /**\n   * Add the Inbound banner to HTML content\n   */\n  private addBannerToHtml(htmlContent: string, params: { originalEmail: ParsedEmailData; recipientEmail?: string }): string {\n    // Only add banner if we have the necessary information\n    if (!params.recipientEmail || !params.originalEmail.from?.addresses?.[0]?.address) {\n      return htmlContent\n    }\n\n    const senderEmail = params.originalEmail.from.addresses[0].address\n    const recipientEmail = params.recipientEmail\n    \n    // Generate the banner HTML (recipientEmail is what we want to block, senderEmail is just for context)\n    const bannerHtml = generateEmailBannerHTML(recipientEmail, senderEmail)\n    \n    // Try to insert banner before closing body tag, or append if no body tag found\n    if (htmlContent.includes('</body>')) {\n      return htmlContent.replace('</body>', `${bannerHtml}</body>`)\n    } else if (htmlContent.includes('</html>')) {\n      return htmlContent.replace('</html>', `${bannerHtml}</html>`)\n    } else {\n      // No proper HTML structure, just append\n      return `${htmlContent}${bannerHtml}`\n    }\n  }\n\n  /**\n   * Add the Inbound banner to plain text content\n   */\n  private addBannerToText(textContent: string, params: { originalEmail: ParsedEmailData; recipientEmail?: string }): string {\n    // Only add banner if we have the necessary information\n    if (!params.recipientEmail || !params.originalEmail.from?.addresses?.[0]?.address) {\n      return textContent\n    }\n\n    const recipientEmail = params.recipientEmail\n    \n    // Create a simple plain text version\n    const bannerText = `\n\n---\nsent via inbound.new, block ${recipientEmail}: https://inbound.new/addtoblocklist?email=${encodeURIComponent(recipientEmail)}\n`\n    \n    return `${textContent}${bannerText}`\n  }\n} ","/**\n * Email Router - Core email routing system for inbound emails\n * Routes incoming emails to configured endpoints (webhooks, email forwarding, email groups) based on recipient configuration.\n * Handles both legacy webhook systems and new unified endpoint architecture with fallback logic.\n * Used by the webhook API route after email ingestion to deliver emails to their configured destinations.\n */\n\nimport { db } from '@/lib/db'\nimport { structuredEmails, emailAddresses, endpoints, endpointDeliveries, emailDomains } from '@/lib/db/schema'\nimport { eq, and } from 'drizzle-orm'\nimport { triggerEmailAction } from '@/app/api/inbound/webhook/route'\nimport { EmailForwarder } from './email-forwarder'\nimport { nanoid } from 'nanoid'\nimport type { ParsedEmailData } from './email-parser'\nimport { sanitizeHtml } from './email-parser'\nimport type { Endpoint } from '@/features/endpoints/types'\n\n/**\n * Main email routing function - routes emails to appropriate endpoints\n */\nexport async function routeEmail(emailId: string): Promise<void> {\n  console.log(`üéØ routeEmail - Processing email ID: ${emailId}`)\n\n  try {\n    // Get email with structured data\n    const emailData = await getEmailWithStructuredData(emailId)\n    if (!emailData) {\n      throw new Error('Email not found or missing structured data')\n    }\n\n    // Find associated endpoint for this email\n    if (!emailData.recipient) {\n      throw new Error('Email recipient not found')\n    }\n    \n    // Pass userId to findEndpointForEmail to ensure proper filtering\n    const endpoint = await findEndpointForEmail(emailData.recipient, emailData.userId)\n    if (!endpoint) {\n      console.warn(`‚ö†Ô∏è routeEmail - No endpoint configured for ${emailData.recipient}, falling back to legacy webhook lookup`)\n      // Fallback to existing webhook logic for backward compatibility\n      const result = await triggerEmailAction(emailId)\n      if (!result.success) {\n        // Log the error but don't throw - this allows the email to be processed even without a webhook\n        console.warn(`‚ö†Ô∏è routeEmail - No webhook configured for ${emailData.recipient}: ${result.error || 'Legacy webhook processing failed'}`)\n        console.log(`üìß routeEmail - Email ${emailId} processed but not routed (no webhook/endpoint configured)`)\n        return\n      }\n      return\n    }\n\n    console.log(`üìç routeEmail - Found endpoint: ${endpoint.name} (type: ${endpoint.type}) for ${emailData.recipient}`)\n\n    // Route based on endpoint type\n    switch (endpoint.type) {\n      case 'webhook':\n        await handleWebhookEndpoint(emailId, endpoint)\n        break\n      case 'email':\n      case 'email_group':\n        await handleEmailForwardEndpoint(emailId, endpoint, emailData)\n        break\n      default:\n        throw new Error(`Unknown endpoint type: ${endpoint.type}`)\n    }\n\n    console.log(`‚úÖ routeEmail - Successfully routed email ${emailId} via ${endpoint.type} endpoint`)\n\n  } catch (error) {\n    console.error(`‚ùå routeEmail - Error processing email ${emailId}:`, error)\n    throw error\n  }\n}\n\n/**\n * Get email data with structured information\n */\nasync function getEmailWithStructuredData(emailId: string) {\n  // First get the email record to find the recipient\n  const emailRecord = await db\n    .select({\n      recipient: structuredEmails.emailId, // We'll get this from receivedEmails\n      userId: structuredEmails.userId,\n    })\n    .from(structuredEmails)\n    .where(eq(structuredEmails.emailId, emailId))\n    .limit(1)\n\n  if (!emailRecord[0]) {\n    return null\n  }\n\n  // Get the recipient from receivedEmails table\n  const { receivedEmails } = await import('@/lib/db/schema')\n  const recipientRecord = await db\n    .select({ recipient: receivedEmails.recipient })\n    .from(receivedEmails)\n    .where(eq(receivedEmails.id, emailId))\n    .limit(1)\n\n  const recipient = recipientRecord[0]?.recipient\n\n  // Now get the full structured email data\n  const emailWithStructuredData = await db\n    .select({\n      // Email record fields\n      emailId: structuredEmails.emailId,\n      userId: structuredEmails.userId,\n      \n      // Structured email data (ParsedEmailData)\n      structuredId: structuredEmails.id,\n      messageId: structuredEmails.messageId,\n      date: structuredEmails.date,\n      subject: structuredEmails.subject,\n      fromData: structuredEmails.fromData,\n      toData: structuredEmails.toData,\n      ccData: structuredEmails.ccData,\n      bccData: structuredEmails.bccData,\n      replyToData: structuredEmails.replyToData,\n      inReplyTo: structuredEmails.inReplyTo,\n      references: structuredEmails.references,\n      textBody: structuredEmails.textBody,\n      htmlBody: structuredEmails.htmlBody,\n      rawContent: structuredEmails.rawContent,\n      attachments: structuredEmails.attachments,\n      headers: structuredEmails.headers,\n      priority: structuredEmails.priority,\n      parseSuccess: structuredEmails.parseSuccess,\n      parseError: structuredEmails.parseError,\n    })\n    .from(structuredEmails)\n    .where(eq(structuredEmails.emailId, emailId))\n    .limit(1)\n\n  const result = emailWithStructuredData[0]\n  if (result) {\n    return {\n      ...result,\n      recipient: recipient || null\n    }\n  }\n\n  return null\n}\n\n/**\n * Find endpoint configuration for an email recipient\n * Priority: endpointId ‚Üí webhookId ‚Üí catch-all endpoint ‚Üí catch-all webhook\n */\nasync function findEndpointForEmail(recipient: string, userId: string): Promise<Endpoint | null> {\n  try {\n    console.log(`üîç findEndpointForEmail - Looking for endpoint for ${recipient} (userId: ${userId})`)\n    \n    // Step 1: Look up the email address to find the configured endpoint\n    const emailAddressRecord = await db\n      .select({\n        endpointId: emailAddresses.endpointId,\n        webhookId: emailAddresses.webhookId, // Keep for backward compatibility\n        address: emailAddresses.address,\n        isActive: emailAddresses.isActive,\n        domainId: emailAddresses.domainId,\n      })\n      .from(emailAddresses)\n      .where(and(\n        eq(emailAddresses.address, recipient),\n        eq(emailAddresses.isActive, true),\n        eq(emailAddresses.userId, userId)\n      ))\n      .limit(1)\n\n    if (emailAddressRecord[0]) {\n      const { endpointId, webhookId } = emailAddressRecord[0]\n\n      // Priority 1: Use endpointId if available\n      if (endpointId) {\n        const endpointRecord = await db\n          .select()\n          .from(endpoints)\n          .where(and(\n            eq(endpoints.id, endpointId),\n            eq(endpoints.isActive, true),\n            eq(endpoints.userId, userId)\n          ))\n          .limit(1)\n\n        if (endpointRecord[0]) {\n          console.log(`üìç findEndpointForEmail - Found email-specific endpoint: ${endpointRecord[0].name} for ${recipient}`)\n          return endpointRecord[0]\n        }\n      }\n\n      // Priority 2: Fall back to webhookId for backward compatibility\n      if (webhookId) {\n        console.log(`üîÑ findEndpointForEmail - Using legacy webhook ${webhookId} for ${recipient}`)\n        return null // Return null to trigger legacy webhook processing\n      }\n    }\n\n    // Step 2: Check for domain-level catch-all configuration\n    const domain = recipient.split('@')[1]\n    if (!domain) {\n      console.warn(`‚ö†Ô∏è findEndpointForEmail - Invalid email format: ${recipient}`)\n      return null\n    }\n\n    console.log(`üåê findEndpointForEmail - Checking catch-all configuration for domain: ${domain}`)\n\n    const domainRecord = await db\n      .select({\n        isCatchAllEnabled: emailDomains.isCatchAllEnabled,\n        catchAllEndpointId: emailDomains.catchAllEndpointId,\n        catchAllWebhookId: emailDomains.catchAllWebhookId,\n        domain: emailDomains.domain,\n      })\n      .from(emailDomains)\n      .where(and(\n        eq(emailDomains.domain, domain),\n        eq(emailDomains.isCatchAllEnabled, true),\n        eq(emailDomains.userId, userId)\n      ))\n      .limit(1)\n\n    if (domainRecord[0]) {\n      const { catchAllEndpointId, catchAllWebhookId } = domainRecord[0]\n      console.log(`üåê findEndpointForEmail - Found catch-all domain: ${domain}, endpointId: ${catchAllEndpointId}, webhookId: ${catchAllWebhookId}`)\n\n      // Priority 3: Use catch-all endpoint\n      if (catchAllEndpointId) {\n        const catchAllEndpointRecord = await db\n          .select()\n          .from(endpoints)\n          .where(and(\n            eq(endpoints.id, catchAllEndpointId),\n            eq(endpoints.isActive, true),\n            eq(endpoints.userId, userId)\n          ))\n          .limit(1)\n\n        if (catchAllEndpointRecord[0]) {\n          console.log(`üåê findEndpointForEmail - Found catch-all endpoint: ${catchAllEndpointRecord[0].name} for ${recipient}`)\n          return catchAllEndpointRecord[0]\n        } else {\n          console.warn(`‚ö†Ô∏è findEndpointForEmail - Catch-all endpoint ${catchAllEndpointId} not found or inactive`)\n        }\n      }\n\n      // Priority 4: Fall back to catch-all webhook for backward compatibility\n      if (catchAllWebhookId) {\n        console.log(`üîÑ findEndpointForEmail - Using catch-all legacy webhook ${catchAllWebhookId} for ${recipient}`)\n        return null // Return null to trigger legacy webhook processing\n      }\n    } else {\n      console.warn(`‚ö†Ô∏è findEndpointForEmail - No catch-all domain configuration found for ${domain} (userId: ${userId})`)\n    }\n\n    console.warn(`‚ö†Ô∏è findEndpointForEmail - No endpoint, webhook, or catch-all configuration found for ${recipient}`)\n    return null\n\n  } catch (error) {\n    console.error(`‚ùå findEndpointForEmail - Error finding endpoint for ${recipient}:`, error)\n    return null\n  }\n}\n\n/**\n * Handle webhook endpoint routing (direct implementation for unified endpoints)\n */\nasync function handleWebhookEndpoint(emailId: string, endpoint: Endpoint): Promise<void> {\n  try {\n    console.log(`üì° handleWebhookEndpoint - Processing webhook endpoint: ${endpoint.name}`)\n\n    // Get email with structured data\n    const emailData = await getEmailWithStructuredData(emailId)\n    if (!emailData) {\n      throw new Error('Email not found or missing structured data')\n    }\n\n    // Parse endpoint configuration\n    const config = JSON.parse(endpoint.config)\n    const webhookUrl = config.url\n    const timeout = config.timeout || 30\n    const retryAttempts = config.retryAttempts || 3\n    const customHeaders = config.headers || {}\n\n    if (!webhookUrl) {\n      throw new Error('Webhook URL not configured')\n    }\n\n    console.log(`üì§ handleWebhookEndpoint - Sending email ${emailData.messageId} to webhook: ${endpoint.name} (${webhookUrl})`)\n\n    // Reconstruct ParsedEmailData from structured data\n    const parsedEmailData = reconstructParsedEmailData(emailData)\n\n    // Create webhook payload with the exact structure expected\n    const webhookPayload = {\n      event: 'email.received',\n      timestamp: new Date().toISOString(),\n      email: {\n        id: emailData.structuredId, // Use structured email ID for v2 API compatibility\n        messageId: emailData.messageId,\n        from: emailData.fromData ? JSON.parse(emailData.fromData) : null,\n        to: emailData.toData ? JSON.parse(emailData.toData) : null,\n        recipient: emailData.recipient,\n        subject: emailData.subject,\n        receivedAt: emailData.date,\n        \n        // Full ParsedEmailData structure\n        parsedData: parsedEmailData,\n        \n        // Cleaned content for backward compatibility\n        cleanedContent: {\n          html: parsedEmailData.htmlBody ? sanitizeHtml(parsedEmailData.htmlBody) : null,\n          text: parsedEmailData.textBody || null,\n          hasHtml: !!parsedEmailData.htmlBody,\n          hasText: !!parsedEmailData.textBody,\n          attachments: parsedEmailData.attachments || [],\n          headers: parsedEmailData.headers || {}\n        }\n      },\n      endpoint: {\n        id: endpoint.id,\n        name: endpoint.name,\n        type: endpoint.type\n      }\n    }\n\n    const payloadString = JSON.stringify(webhookPayload)\n\n    // Prepare headers\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      'User-Agent': 'InboundEmail-Webhook/1.0',\n      'X-Webhook-Event': 'email.received',\n      'X-Endpoint-ID': endpoint.id,\n      'X-Webhook-Timestamp': webhookPayload.timestamp,\n      'X-Email-ID': emailData.structuredId, // Use structured email ID for v2 API compatibility\n      'X-Message-ID': emailData.messageId || '',\n      ...customHeaders\n    }\n\n    // Send the webhook\n    const startTime = Date.now()\n    let deliverySuccess = false\n    let responseCode = 0\n    let responseBody = ''\n    let errorMessage = ''\n    let deliveryTime = 0\n\n    try {\n      const response = await fetch(webhookUrl, {\n        method: 'POST',\n        headers,\n        body: payloadString,\n        signal: AbortSignal.timeout(timeout * 1000)\n      })\n\n      deliveryTime = Date.now() - startTime\n      responseCode = response.status\n      responseBody = await response.text().catch(() => 'Unable to read response body')\n      deliverySuccess = response.ok\n\n      console.log(`${deliverySuccess ? '‚úÖ' : '‚ùå'} handleWebhookEndpoint - Delivery ${deliverySuccess ? 'succeeded' : 'failed'} for ${emailData.recipient}: ${responseCode} in ${deliveryTime}ms`)\n\n    } catch (error) {\n      deliveryTime = Date.now() - startTime\n      deliverySuccess = false\n      \n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          errorMessage = `Request timeout after ${timeout}s`\n        } else {\n          errorMessage = error.message\n        }\n      } else {\n        errorMessage = 'Unknown error'\n      }\n\n      console.error(`‚ùå handleWebhookEndpoint - Delivery failed for ${emailData.recipient}:`, errorMessage)\n    }\n\n    // Track delivery in new endpoint deliveries table\n    await trackEndpointDelivery(\n      emailId, \n      endpoint.id, \n      'webhook', \n      deliverySuccess ? 'success' : 'failed',\n      { \n        responseCode,\n        responseBody: responseBody ? responseBody.substring(0, 2000) : null, // Limit response body size\n        deliveryTime,\n        error: errorMessage || null,\n        url: webhookUrl,\n        deliveredAt: new Date().toISOString()\n      }\n    )\n\n    if (!deliverySuccess) {\n      throw new Error(errorMessage || 'Webhook delivery failed')\n    }\n\n    console.log(`‚úÖ handleWebhookEndpoint - Successfully delivered email ${emailId} to webhook ${endpoint.name}`)\n\n  } catch (error) {\n    console.error(`‚ùå handleWebhookEndpoint - Error processing webhook endpoint:`, error)\n    throw error\n  }\n}\n\n\n\n/**\n * Handle email forwarding endpoints (email and email_group types)\n */\nasync function handleEmailForwardEndpoint(\n  emailId: string, \n  endpoint: Endpoint, \n  emailData: any\n): Promise<void> {\n  try {\n    console.log(`üì® handleEmailForwardEndpoint - Processing ${endpoint.type} endpoint: ${endpoint.name}`)\n\n    const config = JSON.parse(endpoint.config)\n    const forwarder = new EmailForwarder()\n    \n    // Reconstruct ParsedEmailData from structured data\n    const parsedEmailData = reconstructParsedEmailData(emailData)\n    \n    // Determine recipient addresses based on endpoint type\n    const toAddresses = endpoint.type === 'email_group' \n      ? config.emails \n      : [config.forwardTo]\n    \n    // Use the original recipient as the from address (e.g., ryan@inbound.new)\n    const fromAddress = config.fromAddress || emailData.recipient\n    \n    console.log(`üì§ handleEmailForwardEndpoint - Forwarding to ${toAddresses.length} recipients from ${fromAddress}`)\n\n    // Forward the email\n    await forwarder.forwardEmail(\n      parsedEmailData,\n      fromAddress,\n      toAddresses,\n      {\n        subjectPrefix: config.subjectPrefix,\n        includeAttachments: config.includeAttachments,\n        recipientEmail: emailData.recipient\n      }\n    )\n    \n    // Track successful delivery\n    await trackEndpointDelivery(\n      emailId, \n      endpoint.id, \n      'email_forward', \n      'success',\n      { \n        toAddresses, \n        fromAddress,\n        forwardedAt: new Date().toISOString()\n      }\n    )\n\n    console.log(`‚úÖ handleEmailForwardEndpoint - Successfully forwarded email to ${toAddresses.length} recipients`)\n\n  } catch (error) {\n    console.error(`‚ùå handleEmailForwardEndpoint - Error forwarding email:`, error)\n    \n    // Track failed delivery\n    await trackEndpointDelivery(\n      emailId, \n      endpoint.id, \n      'email_forward', \n      'failed',\n      { \n        error: error instanceof Error ? error.message : 'Unknown error',\n        failedAt: new Date().toISOString()\n      }\n    )\n    \n    throw error\n  }\n}\n\n/**\n * Reconstruct ParsedEmailData from structured email data\n */\nfunction reconstructParsedEmailData(emailData: any): ParsedEmailData {\n  return {\n    messageId: emailData.messageId || undefined,\n    date: emailData.date || undefined,\n    subject: emailData.subject || undefined,\n    from: emailData.fromData ? JSON.parse(emailData.fromData) : null,\n    to: emailData.toData ? JSON.parse(emailData.toData) : null,\n    cc: emailData.ccData ? JSON.parse(emailData.ccData) : null,\n    bcc: emailData.bccData ? JSON.parse(emailData.bccData) : null,\n    replyTo: emailData.replyToData ? JSON.parse(emailData.replyToData) : null,\n    inReplyTo: emailData.inReplyTo || undefined,\n    references: emailData.references ? JSON.parse(emailData.references) : undefined,\n    textBody: emailData.textBody || undefined,\n    htmlBody: emailData.htmlBody || undefined,\n    raw: emailData.rawContent || undefined,\n    attachments: emailData.attachments ? JSON.parse(emailData.attachments) : [],\n    headers: emailData.headers ? JSON.parse(emailData.headers) : {},\n    priority: emailData.priority === 'false' ? false : (emailData.priority || undefined)\n  }\n}\n\n/**\n * Get default from address using verified domain\n */\nasync function getDefaultFromAddress(recipient: string): Promise<string> {\n  try {\n    const domain = recipient.split('@')[1]\n    if (!domain) {\n      throw new Error('Invalid recipient email format')\n    }\n\n    // Look up verified domain\n    const domainRecord = await db\n      .select({ domain: emailDomains.domain })\n      .from(emailDomains)\n      .where(and(\n        eq(emailDomains.domain, domain),\n        eq(emailDomains.status, 'verified'),\n        eq(emailDomains.canReceiveEmails, true)\n      ))\n      .limit(1)\n\n    if (domainRecord[0]) {\n      return `noreply@${domainRecord[0].domain}`\n    }\n\n    // Fallback to recipient domain if not found in our records\n    return `noreply@${domain}`\n\n  } catch (error) {\n    console.error('‚ùå getDefaultFromAddress - Error getting default from address:', error)\n    // Ultimate fallback\n    return 'noreply@example.com'\n  }\n}\n\n/**\n * Track endpoint delivery in the unified deliveries table\n */\nasync function trackEndpointDelivery(\n  emailId: string,\n  endpointId: string,\n  deliveryType: 'webhook' | 'email_forward',\n  status: 'pending' | 'success' | 'failed',\n  responseData?: any\n): Promise<void> {\n  try {\n    const deliveryRecord = {\n      id: nanoid(),\n      emailId,\n      endpointId,\n      deliveryType,\n      status,\n      attempts: 1,\n      lastAttemptAt: new Date(),\n      responseData: responseData ? JSON.stringify(responseData) : null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }\n\n    await db.insert(endpointDeliveries).values(deliveryRecord)\n    console.log(`üìä trackEndpointDelivery - Tracked ${deliveryType} delivery: ${status}`)\n\n  } catch (error) {\n    console.error('‚ùå trackEndpointDelivery - Error tracking delivery:', error)\n    // Don't throw here as this is just tracking\n  }\n} ","// THIS IS THE PRIMARY WEBHOOK FOR PROCESSING EMAILS DO NOT DELETE THIS FILE\n\nimport { NextRequest, NextResponse } from 'next/server'\nimport { db } from '@/lib/db'\nimport { sesEvents, receivedEmails, parsedEmails, structuredEmails, emailDomains, emailAddresses, webhooks, webhookDeliveries } from '@/lib/db/schema'\nimport { nanoid } from 'nanoid'\nimport { eq, and } from 'drizzle-orm'\nimport { Autumn as autumn } from 'autumn-js'\nimport { createHmac } from 'crypto'\nimport { parseEmail, sanitizeHtml, type ParsedEmailData } from '@/lib/email-management/email-parser'\nimport { type SESEvent, type SESRecord } from '@/lib/aws-ses/aws-ses'\nimport { isEmailBlocked } from '@/lib/email-management/email-blocking'\nimport { routeEmail } from '@/lib/email-management/email-router'\n\ninterface ProcessedSESRecord extends SESRecord {\n  emailContent?: string | null\n  s3Location?: {\n    bucket: string\n    key: string\n    contentFetched: boolean\n    contentSize: number\n  }\n  s3Error?: string\n}\n\ninterface WebhookPayload {\n  type: 'ses_event_with_content'\n  timestamp: string\n  originalEvent: SESEvent\n  processedRecords: ProcessedSESRecord[]\n  context: {\n    functionName: string\n    functionVersion: string\n    requestId: string\n  }\n}\n\n/**\n * Extract domain from email address\n */\nfunction extractDomain(email: string): string {\n  return email.split('@')[1]?.toLowerCase() || ''\n}\n\n/**\n * Map recipient email to user ID by looking up domain owner\n * This function handles the mapping of email recipients to user IDs by:\n * 1. Extracting the domain from the recipient email\n * 2. Looking up the domain owner in the emailDomains table\n * 3. Returning the userId or 'system' as fallback\n */\nasync function mapRecipientToUserId(recipient: string): Promise<string> {\n  try {\n    // Validate email format first\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n    if (!emailRegex.test(recipient)) {\n      console.warn(`‚ö†Ô∏è Webhook - Invalid email format: ${recipient}`)\n      return 'system'\n    }\n\n    const domain = extractDomain(recipient)\n    \n    if (!domain) {\n      console.warn(`‚ö†Ô∏è Webhook - Could not extract domain from recipient: ${recipient}`)\n      return 'system'\n    }\n\n    console.log(`üîç Webhook - Looking up domain owner for: ${domain}`)\n\n    // Look up the domain in the emailDomains table to find the owner\n    const domainRecord = await db\n      .select({ \n        userId: emailDomains.userId,\n        status: emailDomains.status,\n        canReceiveEmails: emailDomains.canReceiveEmails\n      })\n      .from(emailDomains)\n      .where(eq(emailDomains.domain, domain))\n      .limit(1)\n\n    if (domainRecord[0]?.userId) {\n      const { userId, status, canReceiveEmails } = domainRecord[0]\n      \n      // Log domain status for debugging\n      console.log(`‚úÖ Webhook - Found domain ${domain}: status=${status}, canReceiveEmails=${canReceiveEmails}, userId=${userId}`)\n      \n      // Check if domain is properly configured to receive emails\n      if (!canReceiveEmails) {\n        console.warn(`‚ö†Ô∏è Webhook - Domain ${domain} is not configured to receive emails, but processing anyway`)\n      }\n      \n      return userId\n    } else {\n      console.warn(`‚ö†Ô∏è Webhook - No domain owner found for ${domain} (recipient: ${recipient}), using system`)\n      return 'system'\n    }\n  } catch (error) {\n    console.error(`‚ùå Webhook - Error mapping recipient ${recipient} to user:`, error)\n    return 'system'\n  }\n}\n\n/**\n * Check and track inbound trigger usage for a user\n */\nasync function checkAndTrackInboundTrigger(userId: string, recipient: string): Promise<{ allowed: boolean; error?: string }> {\n  // Skip tracking for system emails\n  if (userId === 'system') {\n    console.log(`üìß Webhook - Skipping inbound trigger check for system email: ${recipient}`)\n    return { allowed: true }\n  }\n\n  try {\n    // Check if user can use inbound triggers\n    const { data: triggerCheck, error: triggerCheckError } = await autumn.check({\n      customer_id: userId,\n      feature_id: \"inbound_triggers\",\n    })\n\n    if (triggerCheckError) {\n      console.error(`‚ùå Webhook - Autumn inbound trigger check error for user ${userId}:`, triggerCheckError)\n      return { \n        allowed: false, \n        error: `Failed to check inbound trigger limits: ${triggerCheckError}` \n      }\n    }\n\n    if (!triggerCheck?.allowed) {\n      console.warn(`‚ö†Ô∏è Webhook - User ${userId} not allowed to use inbound triggers for email: ${recipient}`)\n      return { \n        allowed: false, \n        error: 'Inbound trigger limit reached. Please upgrade your plan to process more emails.' \n      }\n    }\n\n    // Track the inbound trigger usage if allowed and not unlimited\n    if (!triggerCheck.unlimited) {\n      const { error: trackError } = await autumn.track({\n        customer_id: userId,\n        feature_id: \"inbound_triggers\",\n        value: 1,\n      })\n\n      if (trackError) {\n        console.error(`‚ùå Webhook - Failed to track inbound trigger usage for user ${userId}:`, trackError)\n        return { \n          allowed: false, \n          error: `Failed to track inbound trigger usage: ${trackError}` \n        }\n      }\n\n      console.log(`üìä Webhook - Tracked inbound trigger usage for user ${userId}, email: ${recipient}`)\n    } else {\n      console.log(`‚ôæÔ∏è Webhook - User ${userId} has unlimited inbound triggers, no tracking needed for: ${recipient}`)\n    }\n\n    return { allowed: true }\n  } catch (error) {\n    console.error(`‚ùå Webhook - Error checking/tracking inbound trigger for user ${userId}:`, error)\n    return { \n      allowed: false, \n      error: `Inbound trigger check failed: ${error instanceof Error ? error.message : 'Unknown error'}` \n    }\n  }\n}\n\n/**\n * Create a parsed email record from ParsedEmailData\n */\nasync function createParsedEmailRecord(emailId: string, parsedEmailData: ParsedEmailData): Promise<void> {\n  try {\n    console.log(`üìù Webhook - Creating parsed email record for ${emailId}`)\n\n    // Helper function to extract first address from ParsedEmailAddress\n    const extractFirstAddress = (addressData: any) => {\n      if (!addressData || !addressData.addresses || addressData.addresses.length === 0) {\n        return { address: null, name: null }\n      }\n      const first = addressData.addresses[0]\n      return {\n        address: first.address || null,\n        name: first.name || null\n      }\n    }\n\n    // Extract primary from address for indexing\n    const fromInfo = extractFirstAddress(parsedEmailData.from)\n\n    // Count attachments\n    const attachmentCount = parsedEmailData.attachments?.length || 0\n    const hasAttachments = attachmentCount > 0\n\n    const parsedEmailRecord = {\n      id: nanoid(),\n      emailId: emailId,\n      messageId: parsedEmailData.messageId || null,\n      \n      // From address fields\n      fromText: parsedEmailData.from?.text || null,\n      fromAddress: fromInfo.address,\n      fromName: fromInfo.name,\n      \n      // To addresses\n      toText: parsedEmailData.to?.text || null,\n      toAddresses: parsedEmailData.to?.addresses ? JSON.stringify(parsedEmailData.to.addresses) : null,\n      \n      // CC addresses\n      ccText: parsedEmailData.cc?.text || null,\n      ccAddresses: parsedEmailData.cc?.addresses ? JSON.stringify(parsedEmailData.cc.addresses) : null,\n      \n      // BCC addresses\n      bccText: parsedEmailData.bcc?.text || null,\n      bccAddresses: parsedEmailData.bcc?.addresses ? JSON.stringify(parsedEmailData.bcc.addresses) : null,\n      \n      // Reply-to addresses\n      replyToText: parsedEmailData.replyTo?.text || null,\n      replyToAddresses: parsedEmailData.replyTo?.addresses ? JSON.stringify(parsedEmailData.replyTo.addresses) : null,\n      \n      // Email content\n      subject: parsedEmailData.subject || null,\n      textBody: parsedEmailData.textBody || null,\n      htmlBody: parsedEmailData.htmlBody || null,\n      \n      // Email threading\n      inReplyTo: parsedEmailData.inReplyTo || null,\n      references: parsedEmailData.references ? JSON.stringify(parsedEmailData.references) : null,\n      \n      // Email metadata\n      priority: typeof parsedEmailData.priority === 'string' ? parsedEmailData.priority : null,\n      emailDate: parsedEmailData.date || null,\n      \n      // Attachments\n      attachments: parsedEmailData.attachments ? JSON.stringify(parsedEmailData.attachments) : null,\n      attachmentCount: attachmentCount,\n      hasAttachments: hasAttachments,\n      \n      // Headers\n      headers: parsedEmailData.headers ? JSON.stringify(parsedEmailData.headers) : null,\n      \n      // Content flags\n      hasTextBody: !!parsedEmailData.textBody,\n      hasHtmlBody: !!parsedEmailData.htmlBody,\n      \n      // Parsing metadata\n      parseSuccess: true,\n      parseError: null,\n      \n      // Timestamps\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }\n\n    await db.insert(parsedEmails).values(parsedEmailRecord)\n    console.log(`‚úÖ Webhook - Created parsed email record ${parsedEmailRecord.id} for email ${emailId}`)\n\n  } catch (error) {\n    console.error(`‚ùå Webhook - Error creating parsed email record for ${emailId}:`, error)\n    \n    // Create a minimal record indicating parse failure\n    try {\n      const failedParseRecord = {\n        id: nanoid(),\n        emailId: emailId,\n        parseSuccess: false,\n        parseError: error instanceof Error ? error.message : 'Unknown parsing error',\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      }\n      await db.insert(parsedEmails).values(failedParseRecord)\n      console.log(`‚ö†Ô∏è Webhook - Created failed parse record for email ${emailId}`)\n    } catch (insertError) {\n      console.error(`‚ùå Webhook - Failed to create failed parse record for ${emailId}:`, insertError)\n    }\n  }\n}\n\n/**\n * Create a structured email record from ParsedEmailData that matches the type exactly\n */\nasync function createStructuredEmailRecord(\n  emailId: string, \n  sesEventId: string, \n  parsedEmailData: ParsedEmailData, \n  userId: string\n): Promise<void> {\n  try {\n    console.log(`üìù Webhook - Creating structured email record for ${emailId}`)\n\n    const structuredEmailRecord = {\n      id: nanoid(),\n      emailId: emailId,\n      sesEventId: sesEventId,\n      \n      // Core email fields matching ParsedEmailData exactly\n      messageId: parsedEmailData.messageId || null,\n      date: parsedEmailData.date || null,\n      subject: parsedEmailData.subject || null,\n      \n      // Address fields - stored as JSON matching ParsedEmailAddress structure\n      fromData: parsedEmailData.from ? JSON.stringify(parsedEmailData.from) : null,\n      toData: parsedEmailData.to ? JSON.stringify(parsedEmailData.to) : null,\n      ccData: parsedEmailData.cc ? JSON.stringify(parsedEmailData.cc) : null,\n      bccData: parsedEmailData.bcc ? JSON.stringify(parsedEmailData.bcc) : null,\n      replyToData: parsedEmailData.replyTo ? JSON.stringify(parsedEmailData.replyTo) : null,\n      \n      // Threading fields\n      inReplyTo: parsedEmailData.inReplyTo || null,\n      references: parsedEmailData.references ? JSON.stringify(parsedEmailData.references) : null,\n      \n      // Content fields\n      textBody: parsedEmailData.textBody || null,\n      htmlBody: parsedEmailData.htmlBody || null,\n      rawContent: parsedEmailData.raw || null,\n      \n      // Attachments - stored as JSON array matching ParsedEmailData structure\n      attachments: parsedEmailData.attachments ? JSON.stringify(parsedEmailData.attachments) : null,\n      \n      // Headers - stored as JSON object matching enhanced headers structure\n      headers: parsedEmailData.headers ? JSON.stringify(parsedEmailData.headers) : null,\n      \n      // Priority field\n      priority: typeof parsedEmailData.priority === 'string' ? parsedEmailData.priority : \n                parsedEmailData.priority === false ? 'false' : null,\n      \n      // Processing metadata\n      parseSuccess: true,\n      parseError: null,\n      \n      // User and timestamps\n      userId: userId,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }\n\n    await db.insert(structuredEmails).values(structuredEmailRecord)\n    console.log(`‚úÖ Webhook - Created structured email record ${structuredEmailRecord.id} for email ${emailId}`)\n\n  } catch (error) {\n    console.error(`‚ùå Webhook - Error creating structured email record for ${emailId}:`, error)\n    \n    // Create a minimal record indicating parse failure\n    try {\n      const failedStructuredRecord = {\n        id: nanoid(),\n        emailId: emailId,\n        sesEventId: sesEventId,\n        parseSuccess: false,\n        parseError: error instanceof Error ? error.message : 'Unknown parsing error',\n        userId: userId,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      }\n      await db.insert(structuredEmails).values(failedStructuredRecord)\n      console.log(`‚ö†Ô∏è Webhook - Created failed structured parse record for email ${emailId}`)\n    } catch (insertError) {\n      console.error(`‚ùå Webhook - Failed to create failed structured parse record for ${emailId}:`, insertError)\n    }\n  }\n}\n\n\n\n/**\n * Trigger email action by emailID - looks up email data and sends to configured webhook\n * This function separates webhook processing from the main email ingestion flow\n */\nexport async function triggerEmailAction(emailId: string): Promise<{ success: boolean; error?: string; deliveryId?: string }> {\n  try {\n    console.log(`üéØ triggerEmailAction - Processing email ID: ${emailId}`)\n\n    // Get the email record with structured data\n    const emailWithStructuredData = await db\n      .select({\n        // Email record fields\n        emailId: receivedEmails.id,\n        messageId: receivedEmails.messageId,\n        from: receivedEmails.from,\n        to: receivedEmails.to,\n        recipient: receivedEmails.recipient,\n        subject: receivedEmails.subject,\n        receivedAt: receivedEmails.receivedAt,\n        userId: receivedEmails.userId,\n        \n        // Structured email data (ParsedEmailData)\n        structuredId: structuredEmails.id,\n        structuredMessageId: structuredEmails.messageId,\n        structuredDate: structuredEmails.date,\n        structuredSubject: structuredEmails.subject,\n        fromData: structuredEmails.fromData,\n        toData: structuredEmails.toData,\n        ccData: structuredEmails.ccData,\n        bccData: structuredEmails.bccData,\n        replyToData: structuredEmails.replyToData,\n        inReplyTo: structuredEmails.inReplyTo,\n        references: structuredEmails.references,\n        textBody: structuredEmails.textBody,\n        htmlBody: structuredEmails.htmlBody,\n        rawContent: structuredEmails.rawContent,\n        attachments: structuredEmails.attachments,\n        headers: structuredEmails.headers,\n        priority: structuredEmails.priority,\n        parseSuccess: structuredEmails.parseSuccess,\n        parseError: structuredEmails.parseError,\n      })\n      .from(receivedEmails)\n      .leftJoin(structuredEmails, eq(receivedEmails.id, structuredEmails.emailId))\n      .where(eq(receivedEmails.id, emailId))\n      .limit(1)\n\n    if (!emailWithStructuredData[0]) {\n      return { success: false, error: 'Email not found' }\n    }\n\n    const emailData = emailWithStructuredData[0]\n\n    // Check if we have structured data\n    if (!emailData.structuredId || !emailData.parseSuccess) {\n      return { \n        success: false, \n        error: `No structured email data found or parsing failed: ${emailData.parseError || 'Unknown error'}` \n      }\n    }\n\n    // Look up the email address to find the configured webhook\n    const emailAddressRecord = await db\n      .select({\n        webhookId: emailAddresses.webhookId,\n        address: emailAddresses.address,\n        isActive: emailAddresses.isActive,\n      })\n      .from(emailAddresses)\n      .where(and(\n        eq(emailAddresses.address, emailData.recipient),\n        eq(emailAddresses.isActive, true)\n      ))\n      .limit(1)\n\n    if (!emailAddressRecord[0]?.webhookId) {\n      return { \n        success: false, \n        error: `No webhook configured for ${emailData.recipient}` \n      }\n    }\n\n    const webhookId = emailAddressRecord[0].webhookId\n\n    // Get the webhook configuration\n    const webhookRecord = await db\n      .select()\n      .from(webhooks)\n      .where(and(\n        eq(webhooks.id, webhookId),\n        eq(webhooks.isActive, true)\n      ))\n      .limit(1)\n\n    if (!webhookRecord[0]) {\n      return { \n        success: false, \n        error: `Webhook ${webhookId} not found or disabled for ${emailData.recipient}` \n      }\n    }\n\n    const webhook = webhookRecord[0]\n\n    console.log(`üì§ triggerEmailAction - Sending email ${emailData.messageId} to webhook: ${webhook.name} (${webhook.url})`)\n\n    // Reconstruct ParsedEmailData from structured data\n    const parsedEmailData: ParsedEmailData = {\n      messageId: emailData.structuredMessageId || undefined,\n      date: emailData.structuredDate || undefined,\n      subject: emailData.structuredSubject || undefined,\n      from: emailData.fromData ? JSON.parse(emailData.fromData) : null,\n      to: emailData.toData ? JSON.parse(emailData.toData) : null,\n      cc: emailData.ccData ? JSON.parse(emailData.ccData) : null,\n      bcc: emailData.bccData ? JSON.parse(emailData.bccData) : null,\n      replyTo: emailData.replyToData ? JSON.parse(emailData.replyToData) : null,\n      inReplyTo: emailData.inReplyTo || undefined,\n      references: emailData.references ? JSON.parse(emailData.references) : undefined,\n      textBody: emailData.textBody || undefined,\n      htmlBody: emailData.htmlBody || undefined,\n      raw: emailData.rawContent || undefined,\n      attachments: emailData.attachments ? JSON.parse(emailData.attachments) : [],\n      headers: emailData.headers ? JSON.parse(emailData.headers) : {},\n      priority: emailData.priority === 'false' ? false : (emailData.priority || undefined)\n    }\n\n    // Create webhook payload with the exact ParsedEmailData structure\n    const webhookPayload = {\n      event: 'email.received',\n      timestamp: new Date().toISOString(),\n      email: {\n        id: emailData.structuredId, // Use structured email ID for v2 API compatibility\n        messageId: emailData.messageId,\n        from: emailData.from,\n        to: JSON.parse(emailData.to),\n        recipient: emailData.recipient,\n        subject: emailData.subject,\n        receivedAt: emailData.receivedAt,\n        \n        // Full ParsedEmailData structure\n        parsedData: parsedEmailData,\n        \n        // Cleaned content for backward compatibility\n        cleanedContent: {\n          html: parsedEmailData.htmlBody ? sanitizeHtml(parsedEmailData.htmlBody) : null,\n          text: parsedEmailData.textBody || null,\n          hasHtml: !!parsedEmailData.htmlBody,\n          hasText: !!parsedEmailData.textBody,\n          attachments: parsedEmailData.attachments || [],\n          headers: parsedEmailData.headers || {}\n        }\n      },\n      webhook: {\n        id: webhook.id,\n        name: webhook.name\n      }\n    }\n\n    const payloadString = JSON.stringify(webhookPayload)\n\n    // Create webhook signature if secret exists\n    let signature = null\n    if (webhook.secret) {\n      const hmac = createHmac('sha256', webhook.secret)\n      hmac.update(payloadString)\n      signature = `sha256=${hmac.digest('hex')}`\n    }\n\n    // Prepare headers\n    const headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      'User-Agent': 'InboundEmail-Webhook/1.0',\n      'X-Webhook-Event': 'email.received',\n      'X-Webhook-ID': webhook.id,\n      'X-Webhook-Timestamp': webhookPayload.timestamp,\n      'X-Email-ID': emailData.structuredId, // Use structured email ID for v2 API compatibility\n      'X-Message-ID': emailData.messageId,\n    }\n\n    if (signature) {\n      headers['X-Webhook-Signature'] = signature\n    }\n\n    // Add custom headers if any\n    if (webhook.headers) {\n      try {\n        const customHeaders = JSON.parse(webhook.headers)\n        Object.assign(headers, customHeaders)\n      } catch (error) {\n        console.error('Error parsing custom headers:', error)\n      }\n    }\n\n    // Create delivery record\n    const deliveryId = nanoid()\n    \n    // Send the webhook\n    const startTime = Date.now()\n    let deliverySuccess = false\n    let responseCode = 0\n    let responseBody = ''\n    let errorMessage = ''\n    let deliveryTime = 0\n\n    try {\n      const response = await fetch(webhook.url, {\n        method: 'POST',\n        headers,\n        body: payloadString,\n        signal: AbortSignal.timeout((webhook.timeout || 30) * 1000)\n      })\n\n      deliveryTime = Date.now() - startTime\n      responseCode = response.status\n      responseBody = await response.text().catch(() => 'Unable to read response body')\n      deliverySuccess = response.ok\n\n      console.log(`${deliverySuccess ? '‚úÖ' : '‚ùå'} triggerEmailAction - Delivery ${deliverySuccess ? 'succeeded' : 'failed'} for ${emailData.recipient}: ${responseCode} in ${deliveryTime}ms`)\n\n    } catch (error) {\n      deliveryTime = Date.now() - startTime\n      deliverySuccess = false\n      \n      if (error instanceof Error) {\n        if (error.name === 'AbortError') {\n          errorMessage = `Request timeout after ${webhook.timeout}s`\n        } else {\n          errorMessage = error.message\n        }\n      } else {\n        errorMessage = 'Unknown error'\n      }\n\n      console.error(`‚ùå triggerEmailAction - Delivery failed for ${emailData.recipient}:`, errorMessage)\n    }\n\n    // Create final delivery record with all data\n    const deliveryRecord = {\n      id: deliveryId,\n      emailId: emailData.emailId,\n      webhookId: webhook.id,\n      endpoint: webhook.url,\n      payload: payloadString,\n      status: deliverySuccess ? 'success' as const : 'failed' as const,\n      attempts: 1,\n      lastAttemptAt: new Date(),\n      responseCode: responseCode || null,\n      responseBody: responseBody ? responseBody.substring(0, 2000) : null, // Limit response body size\n      deliveryTime: deliveryTime,\n      error: errorMessage || null,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    }\n\n    // Store delivery record\n    await db.insert(webhookDeliveries).values(deliveryRecord)\n\n    // Update webhook stats\n    await db\n      .update(webhooks)\n      .set({\n        lastUsed: new Date(),\n        totalDeliveries: (webhook.totalDeliveries || 0) + 1,\n        successfulDeliveries: deliverySuccess ? (webhook.successfulDeliveries || 0) + 1 : (webhook.successfulDeliveries || 0),\n        failedDeliveries: deliverySuccess ? (webhook.failedDeliveries || 0) : (webhook.failedDeliveries || 0) + 1,\n        updatedAt: new Date()\n      })\n      .where(eq(webhooks.id, webhook.id))\n\n    console.log(`üìä triggerEmailAction - Updated webhook stats for ${webhook.name}`)\n\n    return { \n      success: deliverySuccess, \n      error: deliverySuccess ? undefined : errorMessage,\n      deliveryId: deliveryId\n    }\n\n  } catch (error) {\n    console.error(`‚ùå triggerEmailAction - Error processing email ${emailId}:`, error)\n    return { \n      success: false, \n      error: error instanceof Error ? error.message : 'Unknown error' \n    }\n  }\n}\n\nexport async function POST(request: NextRequest) {\n  try {\n    console.log('===============================================')\n    console.log('üìß Webhook - Received email event from Lambda')\n    console.log('===============================================')\n    \n    // Verify the request is from our Lambda function\n    const authHeader = request.headers.get('authorization')\n    const expectedApiKey = process.env.SERVICE_API_KEY\n    \n    if (!authHeader || !expectedApiKey) {\n      console.error('‚ùå Webhook - Missing authentication');\n      return NextResponse.json(\n        { error: 'Missing authentication' },\n        { status: 401 }\n      )\n    }\n\n    const providedKey = authHeader.replace('Bearer ', '')\n    if (providedKey !== expectedApiKey) {\n      console.error('‚ùå Webhook - Invalid authentication');\n      return NextResponse.json(\n        { error: 'Invalid authentication' },\n        { status: 401 }\n      )\n    }\n\n    const payload: WebhookPayload = await request.json()\n    console.log('üîç Webhook - Payload type:', payload.type);\n\n    // Validate payload structure\n    if (payload.type !== 'ses_event_with_content' || !payload.processedRecords) {\n      console.error('‚ùå Webhook - Invalid payload structure');\n      return NextResponse.json(\n        { error: 'Invalid payload structure' },\n        { status: 400 }\n      )\n    }\n\n    const processedEmails: Array<{\n      emailId: string\n      sesEventId: string\n      messageId: string\n      recipient: string\n      subject: string\n      webhookDelivery: { success: boolean; deliveryId?: string; error?: string } | null\n    }> = []\n    \n    const rejectedEmails: Array<{\n      messageId: string\n      recipient: string\n      userId: string\n      reason: string\n      subject: string\n    }> = []\n\n    // Process each enhanced SES record\n    for (const record of payload.processedRecords) {\n      try {\n        const sesData = record.ses\n        console.log('===============================================')\n        console.log('Record Full Data:', JSON.stringify(record, null, 2))\n        console.log('===============================================')\n        const mail = sesData.mail\n        const receipt = sesData.receipt\n\n        console.log(`üì® Webhook - Processing email: ${mail.messageId}`);\n        console.log(`üë• Webhook - Recipients: ${receipt.recipients.join(', ')}`);\n\n        // First, store the SES event\n        const sesEventId = nanoid()\n        const sesEventRecord = {\n          id: sesEventId,\n          eventSource: record.eventSource,\n          eventVersion: record.eventVersion,\n          messageId: mail.messageId,\n          source: mail.source,\n          destination: JSON.stringify(mail.destination),\n          subject: mail.commonHeaders.subject || null,\n          timestamp: new Date(mail.timestamp),\n          receiptTimestamp: new Date(receipt.timestamp),\n          processingTimeMillis: receipt.processingTimeMillis,\n          recipients: JSON.stringify(receipt.recipients),\n          spamVerdict: receipt.spamVerdict.status,\n          virusVerdict: receipt.virusVerdict.status,\n          spfVerdict: receipt.spfVerdict.status,\n          dkimVerdict: receipt.dkimVerdict.status,\n          dmarcVerdict: receipt.dmarcVerdict.status,\n          actionType: receipt.action.type,\n          s3BucketName: receipt.action.bucketName,\n          s3ObjectKey: receipt.action.objectKey,\n          emailContent: record.emailContent || null,\n          s3ContentFetched: record.s3Location?.contentFetched || false,\n          s3ContentSize: record.s3Location?.contentSize || null,\n          s3Error: record.s3Error || null,\n          commonHeaders: JSON.stringify(mail.commonHeaders),\n          rawSesEvent: JSON.stringify(record.ses),\n          lambdaContext: JSON.stringify(payload.context),\n          webhookPayload: JSON.stringify(payload),\n          updatedAt: new Date(),\n        }\n\n        await db.insert(sesEvents).values(sesEventRecord)\n        console.log(`‚úÖ Webhook - Stored SES event ${sesEventId} for message ${mail.messageId}`);\n\n        // Then, create a receivedEmail record for each recipient\n        for (const recipient of receipt.recipients) {\n          const userId = await mapRecipientToUserId(recipient)\n\n          // Check and track inbound trigger usage\n          const triggerResult = await checkAndTrackInboundTrigger(userId, recipient)\n          \n          if (!triggerResult.allowed) {\n            console.warn(`‚ö†Ô∏è Webhook - Rejected email for ${recipient} due to inbound trigger limits: ${triggerResult.error}`)\n            rejectedEmails.push({\n              messageId: mail.messageId,\n              recipient: recipient,\n              userId: userId,\n              reason: triggerResult.error || 'Inbound trigger limit reached',\n              subject: mail.commonHeaders.subject,\n            })\n            continue // Skip processing this recipient\n          }\n\n          // Check if the sender email is blocked\n          const senderBlocked = await isEmailBlocked(mail.source)\n          let emailStatus: 'received' | 'blocked' = 'received'\n          \n          if (senderBlocked) {\n            console.warn(`üö´ Webhook - Email from blocked sender ${mail.source} to ${recipient}`)\n            emailStatus = 'blocked'\n          }\n\n          // Parse the email content using the new parseEmail function\n          let parsedEmailData: ParsedEmailData | null = null\n          console.log('Email content:', record.emailContent)\n          if (record.emailContent) {\n            console.log(`üìßüìßüìß Webhook - Parsing email content for ${mail.messageId}`)\n            try {\n              parsedEmailData = await parseEmail(record.emailContent)\n              console.log(`‚úÖ Webhook - Successfully parsed email content for ${mail.messageId}`)\n            } catch (parseError) {\n              console.error(`‚ùå Webhook - Failed to parse email content for ${mail.messageId}:`, parseError)\n            }\n          }\n\n          const emailRecord = {\n            id: nanoid(),\n            sesEventId: sesEventId,\n            messageId: mail.messageId,\n            from: mail.source,\n            to: JSON.stringify(mail.destination),\n            recipient: recipient,\n            subject: mail.commonHeaders.subject || 'No Subject',\n            \n            // Parsed email data fields\n            fromParsed: parsedEmailData?.from ? JSON.stringify(parsedEmailData.from) : null,\n            toParsed: parsedEmailData?.to ? JSON.stringify(parsedEmailData.to) : null,\n            ccParsed: parsedEmailData?.cc ? JSON.stringify(parsedEmailData.cc) : null,\n            bccParsed: parsedEmailData?.bcc ? JSON.stringify(parsedEmailData.bcc) : null,\n            replyToParsed: parsedEmailData?.replyTo ? JSON.stringify(parsedEmailData.replyTo) : null,\n            \n            // Email content\n            textBody: parsedEmailData?.textBody || null,\n            htmlBody: parsedEmailData?.htmlBody || null,\n            rawEmailContent: record.emailContent || null,\n            \n            // Email metadata\n            inReplyTo: parsedEmailData?.inReplyTo || null,\n            references: parsedEmailData?.references ? JSON.stringify(parsedEmailData.references) : null,\n            priority: typeof parsedEmailData?.priority === 'string' ? parsedEmailData.priority : null,\n            \n            // Attachments and headers\n            attachments: parsedEmailData?.attachments ? JSON.stringify(parsedEmailData.attachments) : null,\n            headers: parsedEmailData?.headers ? JSON.stringify(parsedEmailData.headers) : null,\n            \n            // Timestamps\n            emailDate: parsedEmailData?.date || null,\n            receivedAt: new Date(mail.timestamp),\n            processedAt: new Date(),\n            \n            // Status and tracking\n            status: emailStatus,\n            isRead: false,\n            readAt: null,\n            \n            // Legacy metadata field for backward compatibility\n            metadata: JSON.stringify({\n              recipient: recipient,\n              authResults: {\n                spf: receipt.spfVerdict.status,\n                dkim: receipt.dkimVerdict.status,\n                dmarc: receipt.dmarcVerdict.status,\n                spam: receipt.spamVerdict.status,\n                virus: receipt.virusVerdict.status,\n              },\n              s3Location: record.s3Location || {\n                bucket: receipt.action.bucketName,\n                key: receipt.action.objectKey,\n              },\n              headers: mail.commonHeaders,\n              lambdaContext: payload.context,\n              processingTimeMillis: receipt.processingTimeMillis,\n              emailContent: record.emailContent ? {\n                hasContent: true,\n                contentSize: record.emailContent.length,\n                contentPreview: record.emailContent.substring(0, 500) + (record.emailContent.length > 500 ? '...' : '')\n              } : {\n                hasContent: false,\n                s3Error: record.s3Error\n              },\n              inboundTriggerTracked: true, // Flag to indicate this email was tracked for inbound triggers\n              parsedSuccessfully: !!parsedEmailData, // Flag to indicate if email was successfully parsed\n              senderBlocked: senderBlocked, // Flag to indicate if the sender was blocked\n              blockedReason: senderBlocked ? 'Sender email address is on the blocklist' : null\n            }),\n            userId: userId,\n            updatedAt: new Date(),\n          }\n\n          await db.insert(receivedEmails).values(emailRecord)\n          \n          // Initialize email processing record\n          const emailProcessingRecord = {\n            emailId: emailRecord.id,\n            sesEventId: sesEventId,\n            messageId: mail.messageId,\n            recipient: recipient,\n            subject: mail.commonHeaders.subject,\n            webhookDelivery: null as { success: boolean; deliveryId?: string; error?: string } | null,\n          }\n\n          console.log(`‚úÖ Webhook - Stored email ${mail.messageId} for ${recipient}`);\n\n          // Create parsed email record if we have parsed data\n          if (parsedEmailData) {\n            await createParsedEmailRecord(emailRecord.id, parsedEmailData) // this will be deprecated in the future\n            // Create structured email record that matches ParsedEmailData type exactly\n            await createStructuredEmailRecord(emailRecord.id, sesEventId, parsedEmailData, userId)\n          }\n\n          // Route email using the new unified routing system (skip routing for blocked emails)\n          if (emailStatus === 'blocked') {\n            console.log(`üö´ Webhook - Skipping routing for blocked email ${emailRecord.id} from ${mail.source}`)\n            \n            // Update processing record to indicate blocked\n            emailProcessingRecord.webhookDelivery = {\n              success: false,\n              error: 'Email blocked - sender is on the blocklist'\n            }\n          } else {\n            try {\n              \n              await routeEmail(emailRecord.id)\n              console.log(`‚úÖ Webhook - Successfully routed email ${emailRecord.id}`)\n              \n              // Update processing record with success\n              emailProcessingRecord.webhookDelivery = {\n                success: true,\n                deliveryId: undefined // Will be tracked in endpointDeliveries table\n              }\n            } catch (routingError) {\n              console.error(`‚ùå Webhook - Failed to route email ${emailRecord.id}:`, routingError)\n              \n              // Update processing record with failure\n              emailProcessingRecord.webhookDelivery = {\n                success: false,\n                error: routingError instanceof Error ? routingError.message : 'Unknown routing error'\n              }\n            }\n          }\n\n          // Processing record already updated above in the try/catch block\n\n          processedEmails.push(emailProcessingRecord)\n        }\n      } catch (recordError) {\n        console.error('‚ùå Webhook - Error processing SES record:', recordError);\n        // Continue processing other records\n      }\n    }\n\n    const response = {\n      success: true,\n      processedEmails: processedEmails.length,\n      rejectedEmails: rejectedEmails.length,\n      emails: processedEmails,\n      rejected: rejectedEmails,\n      timestamp: new Date(),\n      lambdaContext: payload.context,\n    }\n\n    console.log(`‚úÖ Webhook - Successfully processed ${processedEmails.length} emails, rejected ${rejectedEmails.length} emails`);\n\n    return NextResponse.json(response)\n  } catch (error) {\n    console.error('üí• Webhook - Processing error:', error)\n    \n    // Return success even on error to prevent Lambda retries\n    return NextResponse.json(\n      { \n        success: false,\n        error: 'Failed to process email webhook',\n        details: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: new Date()\n      },\n      { status: 200 } // Return 200 to prevent retries\n    )\n  }\n}","import {\n  AppRouteRouteModule,\n  type AppRouteRouteModuleOptions,\n} from '../../server/route-modules/app-route/module.compiled'\nimport { RouteKind } from '../../server/route-kind'\nimport { patchFetch as _patchFetch } from '../../server/lib/patch-fetch'\n\nimport * as userland from 'VAR_USERLAND'\n\n// These are injected by the loader afterwards. This is injected as a variable\n// instead of a replacement because this could also be `undefined` instead of\n// an empty string.\ndeclare const nextConfigOutput: AppRouteRouteModuleOptions['nextConfigOutput']\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\n// INJECT:nextConfigOutput\n\nconst routeModule = new AppRouteRouteModule({\n  definition: {\n    kind: RouteKind.APP_ROUTE,\n    page: 'VAR_DEFINITION_PAGE',\n    pathname: 'VAR_DEFINITION_PATHNAME',\n    filename: 'VAR_DEFINITION_FILENAME',\n    bundlePath: 'VAR_DEFINITION_BUNDLE_PATH',\n  },\n  resolvedPagePath: 'VAR_RESOLVED_PAGE_PATH',\n  nextConfigOutput,\n  userland,\n})\n\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { workAsyncStorage, workUnitAsyncStorage, serverHooks } = routeModule\n\nfunction patchFetch() {\n  return _patchFetch({\n    workAsyncStorage,\n    workUnitAsyncStorage,\n  })\n}\n\nexport {\n  routeModule,\n  workAsyncStorage,\n  workUnitAsyncStorage,\n  serverHooks,\n  patchFetch,\n}\n"],"names":["AppRouteRouteModule","RouteKind","patchFetch","_patchFetch","userland","routeModule","definition","kind","APP_ROUTE","page","pathname","filename","bundlePath","resolvedPagePath","nextConfigOutput","workAsyncStorage","workUnitAsyncStorage","serverHooks"],"mappings":"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","ignoreList":[5]}